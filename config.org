* settings
** startup
*** gc
As early as possible do this
#+BEGIN_SRC emacs-lisp
  (use-package gcmh
    :ensure t
    :diminish t
    :init
    (require 'gcmh)
    (gcmh-mode 1)
    :config
    (setq gcmh-verbose t)
    (setq gcmh-high-cons-threshold (* 100 1024 1024)))
#+END_SRC
*** theme
#+BEGIN_SRC emacs-lisp
(use-package doom-themes :ensure t :defer t)
(load-theme 'doom-one t)
(set-frame-font "Monospace-13")
(global-font-lock-mode t)
(setq font-lock-maximum-decoration t)
#+END_SRC
*** start
Disable a bunch of visuals
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode 0)
  (transient-mark-mode 1)
  (blink-cursor-mode -1)
#+END_SRC
Disable startup messages and text in scratch
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t
    inhibit-startup-echo-area-message t
    initial-scratch-message nil)
#+END_SRC
Disable suspend

#+begin_src emacs-lisp
  (use-package frame :bind ("C-z" . nil))
#+end_src
*** warnings
Disable common warnings
#+BEGIN_SRC emacs-lisp
(put 'set-goal-column 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'erase-buffer 'disabled nil)
(put 'downcase-region 'disabled nil)
(setq large-file-warning-threshold (* 120 1024 1024))
#+END_SRC
*** basic settings
#+BEGIN_SRC emacs-lisp
  (setq scroll-step 1
        scroll-margin 3
        scroll-conservatively 9999
        scroll-preserve-screen-position t
        grep-highlight-matches t
        shell-file-name "bash"
        x-alt-keysym 'meta
        kill-ring-max 100
        undo-outer-limit 50000000
        make-backup-files nil
        calendar-mode-line-format nil
        set-mark-command-repeat-pop t
        load-prefer-newer t
        display-raw-bytes-as-hex t
        show-paren-delay 0)

  (show-paren-mode t)

  (setq enable-recursive-minibuffers t)
  (minibuffer-depth-indicate-mode)

  ;;; too slow on old server
  (unless (string= (system-name) "avalenovo")
    (setq completion-styles '(flex)))
#+END_SRC
*** save place
#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :config (save-place-mode))
#+END_SRC
*** save history and desktop
Save some history across sessions. (savehist-mode) on auto-save can be slow so we rely on desktop-save instead
#+BEGIN_SRC emacs-lisp
  (setq history-length 800)
  (setq history-delete-duplicates t)
  (desktop-save-mode -1)

  (setq desktop-globals-to-save
        (append
         '(desktop-missing-file-waning
           (shell-command-history 8000)
           tags-file-name
           tags-table-list
           (search-ring . 8000)
           (regexp-search-ring . 8000)
           (register-alist . 800)
           (kill-ring . 8000)
           (minibuffer-history . 8000)
           (file-name-history . 8000)
           (grep-history . 8000)
           (extended-command-history . 8000)
           (compile-history . 8000)
           (read-expression-history . 8000)
           query-replace-history
           regexp-history)))
#+END_SRC
*** mode bar
show battery, column number and nicely formatted time
#+BEGIN_SRC emacs-lisp
(setq column-number-mode t)
(setq display-time-24hr-format t)
(setq display-time-format "%H:%M - %Y%m%d")
(display-battery-mode t)
(display-time-mode 1)
(size-indication-mode t)
#+END_SRC
*** highlighting
#+BEGIN_SRC emacs-lisp
(global-hi-lock-mode 1)
(setq hi-lock-auto-select-face t)
#+END_SRC
*** emacs server
#+BEGIN_SRC emacs-lisp
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+END_SRC
*** buffers
kill current buffer no prompt
#+BEGIN_SRC emacs-lisp
(defun kill-current-buffer ()
  "Kill the current buffer, without confirmation."
  (interactive)
  (kill-buffer (current-buffer)))
(global-set-key "\C-xk" 'kill-current-buffer)
#+END_SRC

#+begin_src emacs-lisp
  (setq display-buffer-base-action
        '(display-buffer-reuse-mode-window
          display-buffer-reuse-window
          display-buffer-same-window))

  (setq even-window-sizes nil)

  (add-to-list 'same-window-buffer-names "*grep*")
  (add-to-list 'same-window-buffer-names "*Buffer List*")
#+end_src
*** misc
#+BEGIN_SRC emacs-lisp
    (setq display-time-world-time-format "%a, %d %b %I:%M %p %Z"
          display-time-world-list '(("America/Chicago" "Chicago") ("Asia/Tokyo" "Japan")
                                    ("Europe/Berlin" "Frankfurt") ("Australia/Sydney" "Australia")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package winner
    :bind (("M-N" . winner-redo)
           ("M-P" . winner-undo))
    :config
    (when (boundp 'winner-boring-buffers-regexp)
      (setq winner-boring-buffers-regexp "\\*[hH]elm.*"))
    (winner-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
(global-set-key (kbd "C-x l") 'align-regexp)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (global-set-key "\M-z" 'zap-up-to-char)
  (global-set-key "\M-Z" (lambda (char)
                           (interactive "cZap back to char: ")
                           (zap-up-to-char -1 char)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package isearch
    :no-require t
    :defer t
    :config
    (when (version<= "27" emacs-version)
      (setq isearch-lazy-count t
            isearch-allow-scroll 'unlimited))
    (define-key isearch-mode-map [remap isearch-delete-char] #'isearch-del-char))
#+END_SRC

#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src
** development
*** general
#+BEGIN_SRC emacs-lisp
(setq indent-tabs-mode nil)
(setq tab-width 4)
#+END_SRC
*** tags and locate
based on https://emacs.stackexchange.com/questions/41256/using-advice-to-run-function-before-tag-symbol-lookup/41277
check if projectile root has a TAGS file and if not generate something

#+BEGIN_SRC emacs-lisp
  (defun ava/generate-tags ()
    "Generate project TAGS"
    (interactive)
    (cl-assert (projectile-project-root) nil "not in a project")
    (let* ((prjd (projectile-project-root))
           (tagd (concat prjd ".tagsAndLocate"))
           (tagf (concat tagd "/TAGS")))
      (make-directory tagd t)
      (shell-command
       (format "ctags -f %s -e --verbose --totals=yes --links=no \
                --kinds-c++=+p --languages=c,c++,lisp --langmap=c++:+.I \
                -R %s &> %s/ctags.out" tagf prjd tagd))
      (message "generated %s (%s)" tagf
               (shell-command-to-string (format "du -sh %s | cut -f1 | tr -d '\n'" tagf)))))

  ;; TODO only needed if have to locate outside project and no lsp use
  (defun ava/generate-locates ()
    "Generate project locate.db for helm"
    (interactive)
    (cl-assert (projectile-project-root) nil "not in a project"))

  (defun ava/generate-tags-and-locates ()
    "Called interactivel to generate both locate.db and tags for project"
    (interactive)
    (ava/generate-tags)
    (ava/generate-locates))

  (defun ava/before-xref-find-defs (&rest _)
    (when (projectile-project-root)
      (let ((project-tags-file (concat (projectile-project-root) ".tagsAndLocate/TAGS")))
        (if (file-exists-p project-tags-file)
            (visit-tags-table project-tags-file t)
          (ava/generate-tags)))))

  (advice-add 'xref-find-definitions :before #'ava/before-xref-find-defs)
#+END_SRC
*** semantic mode
use semantic without it interfering with completion and without auto-parsing in idle time
(only use it for helm-semantic-or-imenu and thus parses buffer on demand)
#+BEGIN_SRC emacs-lisp
  (require 'semantic)
  (add-hook 'semantic-mode-hook
            (lambda ()
              (dolist (x (default-value 'completion-at-point-functions))
                (when (string-prefix-p "semantic-" (symbol-name x))
                  (remove-hook 'completion-at-point-functions x)))))
  (setq semantic-default-submodes '(global-semanticdb-minor-mode))
  (semantic-mode 1)
#+END_SRC
*** c/c++
indentation related
#+BEGIN_SRC emacs-lisp
(setq c-default-style "linux"
      c-basic-offset 4)
(c-set-offset 'innamespace 0)
#+END_SRC
toggle between implementation and header
#+BEGIN_SRC emacs-lisp
(setq cc-search-directories
'( "/usr/include" "/usr/include/sys" "/usr/include/linux"
   "."
  )
)
(setq cc-other-file-alist
'(("\\.cpp$" (".h" ".hpp"))
("\\.h$" (".cpp" ".c"))
("\\.hpp$" (".cpp" ".c"))
("\\.C$" (".H"))
("\\.H$" (".C"))
))
(add-hook 'c-mode-common-hook (lambda() (global-set-key (kbd "C-c o") 'ff-find-other-file)))
#+END_SRC

*** compilation
#+BEGIN_SRC emacs-lisp
  (setq compile-command "make"
        compilation-always-kill t
        compilation-scroll-output 'first-error
        compilation-read-command nil
        compilation-ask-about-save nil)
#+END_SRC
*** merging
ediff settings
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'ediff
    (setq
     ediff-window-setup-function #'ediff-setup-windows-plain
     ediff-split-window-function #'split-window-horizontally
     ediff-grab-mouse nil
     ediff-keep-variants nil
     ediff-diff-options "-w"))
#+END_SRC
*** re-builder
bridge re-builder with query regexp replace
(from https://karthinks.com/software/bridging-islands-in-emacs-1/)
#+begin_src emacs-lisp
  (use-package re-builder
    :config
    (setq reb-re-syntax 'string)
    (defvar ava/re-builder-positions nil
      "Store point and region bounds before calling re-builder")
    (advice-add 're-builder
                :before
                (defun ava/re-builder-save-state (&rest _)
                  "Save into `ava/re-builder-positions' the point and region
                 positions before calling `re-builder'."
                  (setq ava/re-builder-positions
                        (cons (point)
                              (when (region-active-p)
                                (list (region-beginning)
                                      (region-end)))))))
    (defun ava/reb-replace-regexp (&optional delimited)
      "Run `query-replace-regexp' with the contents of re-builder. With
  non-nil optional argument DELIMITED, only replace matches
  surrounded by word boundaries."
      (interactive "P")
      (reb-update-regexp)
      (let* ((re (reb-target-binding reb-regexp))
             (replacement (query-replace-read-to
                           re
                           (concat "Query replace"
                                   (if current-prefix-arg
                                       (if (eq current-prefix-arg '-) " backward" " word")
                                     "")
                                   " regexp"
                                   (if (with-selected-window reb-target-window
                                         (region-active-p)) " in region" ""))
                           t))
             (pnt (car ava/re-builder-positions))
             (beg (cadr ava/re-builder-positions))
             (end (caddr ava/re-builder-positions)))
        (with-selected-window reb-target-window
          (goto-char pnt) ; replace with (goto-char (match-beginning 0)) if you want
                                          ; to control where in the buffer the replacement starts
                                          ; with re-builder
          (setq ava/re-builder-positions nil)
          (reb-quit)
          (query-replace-regexp re replacement delimited beg end))))

    (define-key reb-mode-map (kbd "RET") #'ava/reb-replace-regexp)
    (define-key reb-lisp-mode-map (kbd "RET") #'ava/reb-replace-regexp)
    (global-set-key (kbd "C-M-%") #'re-builder))
#+end_src
* active packages
** auto package updating
stay up to date
#+BEGIN_SRC emacs-lisp
  (use-package auto-package-update
    :ensure t
    :if (not (daemonp))
    :custom
    (auto-package-update-interval 90)
    (auto-package-update-prompt-before-update t)
    (auto-package-update-delete-old-versions t)
    (auto-package-update-hide-results t)
    :config
    (auto-package-update-maybe))
#+END_SRC
** auctex
#+BEGIN_SRC emacs-lisp
    (use-package tex
      :ensure auctex
      :defer t
      :custom
      (TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
      :hook
      (LaTeX-mode . (lambda ()
                      (turn-on-reftex)
                      (setq reftex-plug-into-AUCTeX t)
                      (reftex-isearch-minor-mode)
                      (setq TeX-source-correlate-start-server t))))

    (use-package company-auctex
      :after tex
      :ensure t
      :commands (company-auctex
                 company-auctext-labels
                 company-auctest-bibs
                 company-auctex-macros
                 company-auctext-symbols
                 company-auctext-environments)
      :hook
      (tex-mode . (lambda ()
                    (setq-local company-backends '((company-auctex-labels
                                                    company-auctex-bibs
                                                    company-auctex-macros
                                                    company-auctex-environments
                                                    company-auctex-symbols
                                                    company-capf))))))
#+END_SRC
** avy
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind (("M-g c" . avy-goto-char-timer)
           ("M-g M-g" . avy-goto-line))
    :config
    (setq avy-timeout-seconds 0.3)
    (when (display-graphic-p) (setq avy-background t)))
#+END_SRC
** bookmarks
modified from https://github.com/howardabrams/dot-files/blob/master/emacs.org
#+begin_src emacs-lisp
  (use-package bookmark
    :init (setq bookmark-save-flag 1)
    :config
    (defun ava/add-bookmark (name)
      (interactive
       (list
        (let* ((initial
                (cond
                 ((and (fboundp 'which-function) (not (string= (projectile-project-name) "-")))
                  (format "%s::%s:%s - " (projectile-project-name) (file-name-base (buffer-file-name)) (which-function)))
                 ((buffer-file-name)
                  (format "%s - " (buffer-file-name)))
                 (t "? - "))))
          (read-string "Bookmark: " initial))))
      (bookmark-set name))
    :bind (("C-x r m" . ava/add-bookmark)))
#+end_src
** clang-format
#+BEGIN_SRC emacs-lisp
  (use-package clang-format
    :ensure t
    :commands clang-format-buffer clang-format-region
    :config
    ;(setq clang-format-executable "TODO")
    (define-key c-mode-base-map "\C-cb" 'clang-format-buffer)
    (define-key c-mode-base-map "\C-cb" 'clang-format-region))
#+END_SRC
** clojure
#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :ensure t
    :mode
    (("\\.clj.*$" . clojure-mode)
     ("\\.edn.*$" . clojure-mode))
    :init
    (add-hook 'clojure-mode-hook #'yas-minor-mode)
    (add-hook 'clojure-mode-hook #'paredit-mode)
    (add-hook 'clojure-mode-hook #'eldoc-mode))

  ;pulls cider
  (use-package clj-refactor
    :ensure t
    :defer t
    :diminish clj-refactor-mode
    :config
    (setq cljr-warn-on-eval nil)
    (cljr-add-keybindings-with-prefix "C-c C-m"))

  (use-package cider
    :ensure t
    :defer t
    :init
    (add-hook 'cider-mode-hook #'clj-refactor-mode)
    (add-hook 'cider-repl-mode-hook #'paredit-mode)
    :config
    (setq cider-repl-use-clojure-font-lock t
          cider-overlays-use-font-lock t
          cider-repl-display-help-banner nil
          cider-repl-pop-to-buffer-on-connect nil
          ;nrepl-log-messages t
          ;cider-preferred-build-tool "boot" ;(if no lein)
          ;cider-prompt-save-file-on-load 'always-save
          ;cider-font-lock-dynamically '(macro core function var)
          ;nrepl-hide-special-buffers t
          )
    (cider-repl-toggle-pretty-printing))
#+END_SRC
** company
*** company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (setq company-idle-delay 0.1
          company-minimum-prefix-length 1
          company-require-match nil
          company-show-numbers t
          company-tooltip-limit 20
          company-tooltip-align-annotations t
          company-selection-wrap-around t
          company-global-modes '(not compilation-mode magit-status-mode reb-mode)
          company-backends '(company-clang company-capf company-files ;company-semantic <-- slow
                                           (company-dabbrev-code company-gtags company-etags company-keywords)
                                           company-dabbrev))
    (define-key company-mode-map (kbd "C-:") 'company-complete-common)
    (define-key company-active-map (kbd "<tab>") 'smarter-yas-expand-next-field-complete)
    (global-company-mode 1)
    (defun smarter-yas-expand-next-field-complete ()
      "Try to `yas-expand' and `yas-next-field' at current cursor position.

  If failed try to complete the common part with `company-complete-common'"
      (interactive)
      (if yas-minor-mode
          (let ((old-point (point))
                (old-tick (buffer-chars-modified-tick)))
            (yas-expand)
            (when (and (eq old-point (point))
                       (eq old-tick (buffer-chars-modified-tick)))
              (ignore-errors (yas-next-field))
              (when (and (eq old-point (point))
                         (eq old-tick (buffer-chars-modified-tick)))
                (company-complete-common))))
        (company-complete-common))))
#+END_SRC
*** posframe
A much nicer frame for completion candidates
#+BEGIN_SRC emacs-lisp
  (use-package company-posframe
    :ensure t
    :config
    (company-posframe-mode 1))
#+END_SRC
*** helm company
#+BEGIN_SRC emacs-lisp
    (use-package helm-company
      :ensure t
      :config
      (define-key company-mode-map (kbd "C-:") 'helm-company))
#+END_SRC
*** company-shell
backend for shells
#+BEGIN_SRC emacs-lisp
  (use-package company-shell
    :ensure t
    :after company
    :config
    (add-to-list 'company-shell-modes 'term-mode)
    (add-hook
     'term-mode-hook (lambda ()
                       (set (make-local-variable 'company-idle-delay) 0.5)
                       (set (make-local-variable 'company-minimum-prefix-length) 2)
                       (set (make-local-variable 'company-backends)
                            '((company-capf company-files company-shell company-shell-env) company-dabbrev)))))
#+END_SRC
** deadgrep
uses rg for fast grep
#+BEGIN_SRC emacs-lisp
  (use-package deadgrep
    :ensure t
    :bind ("M-s g" . deadgrep))
#+END_SRC
** dired related
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'dired
    (require 'dired-x)
    (setq
     dired-recursive-copies 'always
     dired-recursive-deletes 'always
     dired-dwim-target t
     dired-auto-revert-buffer 'dired-directory-changed-p
     dired-listing-switches "-Al --si --time-style long-iso --group-directories-first"
     dired-hide-details-hide-symlink-targets nil)
    (add-hook 'dired-mode-hook (lambda () (interactive) (dired-hide-details-mode 1))))
#+END_SRC
a much nicer dired (can in-place expand subdirectory contents)
#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
             :config
             (define-key dired-mode-map "i" 'dired-subtree-insert)
             (define-key dired-mode-map ";" 'dired-subtree-remove)
             :ensure dired-subtree)
#+END_SRC

replaces list-directory with recentf for dirs
#+begin_src emacs-lisp
  (use-package dired-recent
    :ensure t
    :config (dired-recent-mode 1))
#+end_src

#+BEGIN_SRC emacs-lisp
  ;; (use-package dired-git-info
  ;;   :disabled
  ;;   :ensure t
  ;;   :bind (:map dired-mode-map (")" . dired-git-info-mode))
  ;;   :config
  ;;   (setq dgi-commit-message-format "%f\t%an\t%cr"))
#+END_SRC
** discover
discover major mode
#+BEGIN_SRC emacs-lisp
  (use-package discover-my-major
    :ensure t
    :config
    (global-set-key (kbd "C-h C-m") 'discover-my-major))
#+END_SRC
** easy kill
Use ~M-w~ and modifiers to more efficiently save things to kill ring
#+BEGIN_SRC emacs-lisp
  (use-package easy-kill
  :ensure t
  :config
  (global-set-key [remap kill-ring-save] #'easy-kill)
  (global-set-key [remap mark-sexp] #'easy-mark))
#+END_SRC
** elisp
use =paredit= in lisp modes
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :ensure t
    :config
    (add-hook 'emacs-lisp-mode-hook #'paredit-mode)
    (add-hook 'lisp-interaction-mode-hook #'paredit-mode)
    (add-hook 'ielm-mode-hook #'paredit-mode)
    (add-hook 'lisp-mode-hook #'paredit-mode)
    (add-hook 'eval-expression-minibuffer-setup-hook #'paredit-mode))
#+END_SRC
also enable eldoc
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :diminish
    :hook ((emacs-lisp-mode) . eldoc-mode))
#+END_SRC
** ess
#+BEGIN_SRC emacs-lisp
  (use-package ess
    :ensure t
    :init
    (require 'ess-site)
    :config
    (setq inferior-R-program-name "/usr/bin/R"
          inferior-R-args "--no-save"
          ess-eval-visibly-p nil
          ess-directory "~/"
          ess-use-flymake nil
          ess-indent-with-fancy-comments nil
          ess-ask-for-ess-directory nil)
    ;http://stackoverflow.com/questions/780796/emacs-ess-mode-tabbing-for-comment-region
    (defun ava-ess-settings ()
      (setq ess-indent-with-fancy-comments nil))
    (add-hook 'ess-mode-hook #'ava-ess-settings)
    (define-key ess-r-mode-map "_" #'ess-insert-assign)
    (define-key inferior-ess-r-mode-map "_" #'ess-insert-assign))
#+END_SRC
** expand region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :commands er/expand-region
    :bind ("C-=" . er/expand-region)
    )
#+END_SRC
** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck :ensure t)
#+END_SRC

add clang-tidy to flycheck

#+begin_src emacs-lisp
;  (use-package flycheck-clang-tidy
;    :ensure t
;    :after flycheck
;    :hook (flycheck-mode . flycheck-clang-tidy-setup))
#+end_src

** git-gutter
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :ensure t
    :init
    (global-git-gutter-mode +1))
#+END_SRC
** git-timemachine
#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :ensure t)
#+END_SRC
** helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :demand t
    :diminish helm-mode
    :init
    (progn
      (require 'helm-config)
      (setq helm-candidate-number-limit 100)
      (setq helm-idle-delay 0.0
            helm-input-idle-delay 0.01
            helm-yas-display-key-on-candidate t
            helm-quick-update t
            helm-M-x-requires-pattern nil)
      (helm-mode)
      )
    :bind (
           ("C-h a" . helm-apropos)
           ("C-x b" . helm-mini)
           ("M-y" . helm-show-kill-ring)
           ("M-x" . helm-M-x)
           ("C-x C-f" . helm-find-files)
           ("C-c h o" . helm-occur)
           ("C-c h r" . helm-register)
           ("C-c h b" . helm-resume)
           ("C-c h i" . helm-semantic-or-imenu)
           ("C-c h m" . helm-man-woman)
           ("C-c h I" . helm-imenu-in-all-buffers)
           ("C-c h l" . helm-locate)
           ("C-c h g" . helm-google-suggest)
           ("C-c h t" . helm-top)
           ("C-c h <SPC>" . helm-all-mark-rings))
    :config
    (setq helm-command-prefix-key "C-c h")
    (setq helm-autoresize-min-height 25)
    (setq helm-autoresize-max-height 25)
    (setq helm-split-window-in-side-p t
          helm-move-to-line-cycle-in-source t
          helm-ff-search-library-in-sexp t
          helm-scroll-amount 8
          helm-ff-file-name-history-use-recentf t)
    (setq helm-buffer-max-length nil)
    ;;locate %s -d FOO -e --regex %s where FOO is : delimited from cmd updatedb -l 0 -o i.db -U path_i for all paths
    ;;(defvar my-locate-db-command (with-temp-buffer (insert-file-contents "path/to/cmd.txt") (buffer-string)))
    ;;(setq helm-locate-command my-locae-db-command)
    (helm-mode 1)
    (helm-autoresize-mode 1)
    (define-key  helm-map (kbd "<tab>") 'helm-execute-persistent-action)
    (define-key  helm-map (kbd "C-i") 'helm-execute-persistent-action)
    (define-key  helm-map (kbd "C-z") 'helm-select-action)
    (defun ava/around-helm-buffers-sort-transformer (candidates source)
      candidates)
    (advice-add 'helm-buffers-sort-transformer
                :override #'ava/around-helm-buffers-sort-transformer)
    (defun ava/reset-helm-buffer-max-length (&rest ignore) (setq helm-buffer-max-length nil))
    (advice-add 'helm-mini :before #'ava/reset-helm-buffer-max-length)
    :ensure helm)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package helm-swoop
    :ensure t
    :bind (("C-c h s" . helm-multi-swoop))
    :custom (helm-swoop-speed-or-color t)
    :init
    (bind-key "M-i" 'helm-swoop-from-isearch isearch-mode-map)
    :config
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-current-mode-from-helm-swoop))

  (use-package helm-rg :ensure t)
  (use-package helm-ag :ensure t
    :custom
    (helm-ag-use-agignore t)
    (helm-ag-insert-at-point 'symbol))
#+END_SRC

remap =term-previous-matching-input= to a helm frontend
#+BEGIN_SRC emacs-lisp
  (use-package helm-shell-history
    :load-path "~/.emacs.d/lisp/helm-shell-history"
    :after term vterm
    :config
    (setq helm-shell-history-file "~/.bash_eternal_history")
    (setq helm-shell-history-fuzzy-match t)
    (setq helm-shell-history-fast-parser "~/development/helm-shell-history/src/parse_history")
    (define-key term-mode-map (kbd "M-r") 'helm-shell-history)
    (define-key vterm-mode-map (kbd "M-r") 'helm-shell-history))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package helm-descbinds
    :ensure t
    :init (helm-descbinds-mode))
#+END_SRC
** helpful
#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :ensure t
    :bind
    (("C-h f" . helpful-callable)
     ("C-h v" . helpful-variable)
     ("C-h k" . helpful-key)
     ("C-c C-d" . helpful-at-point)
     ("C-h F" . helpful-funtion)
     ("C-h C" . helpful-command)))
#+END_SRC
** hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure hydra
    :init
    (global-set-key
     (kbd "C-c g")
     (defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1)
                                           :hint nil)
       ("n" git-gutter:next-hunk "next hunk")
       ("p" git-gutter:previous-hunk "previous hunk")
       ("h" (progn (goto-char (point-min)) (git-gutter:next-hunk 1)) "first hunk")
       ("l" (progn (goto-char (point-min)) (git-gutter:previous-hunk 1)) "last hunk")
       ("<SPC>" git-gutter:popup-hunk "popup hunk")
       ("s" git-gutter:stage-hunk "stage hunk")
       ("r" git-gutter:revert-hunk "revert hunk")
       ("q" nil "quit")))

    (global-set-key
     (kbd "C-c e")
     (defhydra hydra-paredit (:hint nil)
       ("f" paredit-forward-slurp-sexp "slurp-forward")
       ("F" paredit-forward-barf-sexp "barf-forward")
       ("b" paredit-backward-slurp-sexp "slurp-backward")
       ("B" paredit-backward-barf-sexp "barf-backward")
       ("n" paredit-foward "forward")
       ("p" paredit-backward "backward")
       ("r" paredit-raise-sexp "raise")
       ("s" paredit-splice-sexp "splice")
       ("u" undo-only "undo")
       ("q" nil "quit")))

    (global-set-key
     (kbd "C-c w")
     (defhydra hydra-windows (:hint nil)
       ("r" rotate-frame-clockwise "clockwise")
       ("\\" rotate-frame-clockwise "anticlockwise")
       ("v" flip-frame "flip")
       ("f" flop-frame "flop")
       ("j" (shrink-window -10) "down")
       ("k" (shrink-window 10) "up")
       ("h" (shrink-window 10 t) "shrink")
       ("l" (shrink-window -10 t) "widen")
       ("0" (balance-windows) "balance")
       ("q" nil "quit"))))
#+END_SRC
** ibuffer
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind ("C-x C-b" . ibuffer))
#+END_SRC
** iedit
#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure t
    :bind ("C-;" . iedit-mode)
    :config
    (setq iedit-toggle-key-default nil)
    (define-key iedit-mode-occurrence-keymap (kbd "RET") 'iedit-mode)
    :diminish)
#+END_SRC
** irc
#+BEGIN_SRC emacs-lisp
  (use-package erc
    :ensure t
    :config
    (setq erc-lurker-hide-list '("PART" "QUIT" "JOIN")
          erc-server "irc.libera.chat"
          erc-nick "hooxen"
          erc-join-buffer 'bury
          erc-interpret-mirc-color t
          erc-server-reconnect-timeout 30)
    (add-hook 'erc-text-matched-hook '(lambda (match-type nickuserhost msg)
                                        (shell-command-to-string (format "notify-send erc '%s'" msg))))
    (use-package erc-colorize
      :ensure t
      :config (erc-colorize-mode 1)))

#+END_SRC
** lsp
Some references here:
[[https://github.com/MaskRay/ccls/wiki/lsp-mode][ccls + lsp]]
[[https://github.com/rememberYou/.emacs.d/blob/master/config.org#lsp][example A]]
[[https://github.com/MatthewZMD/.emacs.d#org75e3a83][example B]] and [[https://github.com/MatthewZMD/.emacs.d#orga4fa68f][B2]]
[[http://ivanmalison.github.io/dotfiles/#languageserverprotocollsp][example C]]
[[https://github.com/jimeh/.emacs.d/blob/master/modules/lsp/siren-lsp.el][goodies]]
[[https://github.com/waymondo/hemacs/blob/master/init.el][lsp-ui goodies]]
[[https://github.com/novoid/dot-emacs/blob/master/config.org][lsp-ui more goodies]]
[[https://emacs-lsp.github.io/lsp-mode/tutorials/how-to-turn-off/][how-to-turn-off]]
[[http://blog.binchen.org/posts/how-to-speed-up-lsp-mode/][example D]]

Only use lsp with flycheck
(rather than hook, manual enable via ==M-x lsp==)
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :ensure t
    :after flycheck
    :commands lsp
    :custom
    (lsp-auto-configure t)
    (lsp-eldoc-hook nil)
    (lsp-eldoc-enable-hover t)
    (lsp-diagnostics-provider :none)
    (lsp-enable-symbol-highlighting nil)
    (lsp-headerline-breadcrumb-enable nil)
    (lsp-lens-enable t)
    (lsp-modeline-code-actions-enable t)
    (lsp-modeline-diagnostics-enable nil)
    (lsp-signature-render-documentation t)
    (lsp-completion-show-kind t)
    (lsp-completion-show-detail t)
    (lsp-enable-file-watchers t)
    (lsp-file-watch-threshold nil)
    (lsp-enable-xref t)
    (lsp-enable-imenu t)
    (lsp-enable-folding nil)
    (lsp-enable-links nil)
    (lsp-keymap-prefix "C-c u")
    (read-process-output-max (* 1024 1024))
    ;:config
    ;(define-key  lsp-mode-map (kbd "C-c u") 'lsp-describe-thing-at-point)
    )
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (use-package lsp-ui
      :ensure t
      :after lsp-mode flycheck
      :diminish
      :commands lsp-ui-mode
      :bind
      (:map lsp-ui-mode-map
            ([remap xref-find-references] . lsp-ui-peek-find-references)
            ([remap xref-find-definitions] . lsp-ui-peek-find-definitions)
            ;("C-c u" . lsp-ui-imenu)
            ;("C-c C-d" . lsp-ui-doc-glance)
            ("C-c d" . lsp-ui-doc-show)
            ("M-i" . lsp-ui-doc-focus-frame))
      :custom
      (lsp-ui-peek-enable t)
      (lsp-ui-doc-enable t)
      (lsp-ui-doc-alignment 'window)
      (lsp-ui-doc-header t)
      (lsp-ui-doc-max-height 45)
      (lsp-ui-doc-position 'at-point)
      (lsp-ui-doc-show-with-mouse nil)
      (lsp-ui-doc-show-with-cursor nil)
      (lsp-ui-doc-include-signature t)
      (lsp-ui-doc-border (face-foreground 'default))
      (lsp-ui-sideline-enable t)
      (lsp-ui-sideline-ignore-duplicate t)
      (lsp-ui-sideline-show-code-actions t)
      (lsp-ui-sideline-show-diagnostics nil)
      (lsp-ui-sideline-show-hover nil))

  ;(use-package company-lsp
  ;    :ensure t
  ;    :custom (company-lsp-cache-candidates 'auto))
#+END_SRC
** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :custom
    (magit-display-buffer-function #'magit-display-buffer-fullcolumn-most-v1)
    (magit-log-section-commit-count 25)
    (magit-diff-refine-hunk 'all)
    :bind
    ("C-x g" . magit-status)
    ("C-c m" . magit-file-dispatch))
#+END_SRC

clean up staged code
#+BEGIN_SRC emacs-lisp
  (defun ava/format-staged ()
    (interactive)
    (dolist (name (magit-staged-files))
      (let ((fname (expand-file-name name (magit-toplevel))))
        (when (file-exists-p fname)
          (pcase (file-name-extension name)
            ("py"
             (shell-command (format "dos2unix -q %s" fname)))
            ((or "C" "H" "I" "c" "h" "cpp" "hpp")
             (shell-command (format "dos2unix -q %s && clang-format --style=file -i %s" fname fname))))))))
#+END_SRC
** move-text
meta up and down to move text or region
#+begin_src emacs-lisp
  (use-package move-text :ensure t :config (move-text-default-bindings))
#+end_src
** multiple cursors
the hydra here [[http://ivanmalison.github.io/dotfiles/][hydra-example]] not working well...
pull in phi-search as well to get incremental search while in mc
(protip: easy-kill ==C-SPC== will turn selection into region)
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :custom (mc/always-run-for-all t)
    :config
    (progn
      (use-package phi-search-mc
        :ensure t
        :config
        (phi-search-mc/setup-keys)))
    :bind (("C-c i e" . mc/mark-all-like-this)
           ("C-c i l" . mc/edit-lines)
           ("C-c i s" . mc/mark-all-symbols-like-this)
           ("C-c i d" . mc/mark-all-symbols-like-this-in-defun)
           ("C-c i r" . mc/mark-all-in-region-regexp)
           ("C-<"   . mc/mark-previous-like-this)
           ("C->"   . mc/mark-next-like-this)
           :map mc/keymap ("C-s" . phi-search)))
#+END_SRC
** org
use bullet mode
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+END_SRC

now configure org (default installed)
#+BEGIN_SRC emacs-lisp
  (setq org-use-speed-commands 1
        org-list-description-max-indent 5
        org-export-html-postamble nil
        org-log-done 'note
        org-cycle-separator-lines 0
        org-deadline-warning-days 7
        org-imenu-depth 10)

  (add-hook 'org-mode-hook 'org-indent-mode)

  (setq org-confirm-babel-evaluate nil)
  (org-babel-do-load-languages 'org-babel-load-languages '( (emacs-lisp . t) (shell . t) (R . t) ))

  (global-set-key (kbd "C-c a") 'org-agenda)
  (setq org-agenda-files (quote ("~/todo.org")))
  (setq org-agenda-window-setup (quote current-window))

  (define-key global-map (kbd "C-c l") 'org-store-link)
  (define-key global-map (kbd "C-c c") 'org-capture)
  (setq org-capture-templates
        '(("t" "Todo" entry (file+headline "~/todo.org" "Tasks")
           "* TODO %?")
          ("l" "Link" entry (file+headline "~/todo.org" "Links")
           "* %^L %? %^g")))

  (require 'org-tempo)
  (add-to-list 'org-structure-template-alist '("sh" . "src bash"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))
  (add-to-list 'org-structure-template-alist '("R" . "src R"))
#+END_SRC
use org-mime to compose email with org mode
#+BEGIN_SRC emacs-lisp
  (use-package org-mime
    :ensure t
    :config
    (setq mail-host-address (getenv "HOST")
          org-mime-export-options '(:section-numbers nil
                                    :with-author nil
                                    :with-toc nil)))
#+END_SRC
** projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :custom
    (projectile-project-root-files-bottom-up '(".git" ".projectile"))
    ;; (projectile-project-root-files '("WORKSPACE"))
    :init
    (setq projectile-enable-caching t
          projectile-project-search-path '("~/development"))
    (when (executable-find "rg")
      (setq projectile-generic-command "rg -0 --hidden --files --color never"))
    :config
    (projectile-mode t)
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    (define-key projectile-mode-map (kbd "C-c p t") 'projectile-run-vterm)
    (define-key projectile-mode-map (kbd "C-c p R") 'ava/generate-tags)
    (use-package helm-projectile
      :ensure t
      :init
      (helm-projectile-on)
      (setq projectile-switch-project-action #'helm-projectile)
      (setq projectile-completion-system 'helm)))
#+END_SRC
** python
To use a venv set a pyvenv-activate directory local or file local variable to the venv path
#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :ensure t
    :commands elpy-enable
    :init
    (progn
      (elpy-enable)
      (setq elpy-modules
            '(elpy-module-sane-defaults
              elpy-module-company
              elpy-module-eldoc
              elpy-module-highlight-indentation
              elpy-module-pyvenv
              elpy-module-yasnippet
              elpy-module-folding))
      (eval-after-load "elpy"
        '(cl-dolist (key '("C-<return>" "C-<up>" "C-<down>" "C-<left>" "C-<right>"))
           (define-key elpy-mode-map (kbd key) nil)))
      :config
      (setq python-shell-interpreter "jupyter")
      (setq python-shell-interpreter-args "console --simple-prompt")
      (setq elpy-rpc-python-command "python")
      (setq elpy-rpc-timeout 10)
      (setq python-shell-prompt-detect-failure-warning nil)
      (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
      (add-hook 'elpy-mode-hook (lambda () (elpy-shell-toggle-dedicated-shell 1)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package python-black
    :ensure t
    :after (python)
    :config
    (setq python-black-command "/usr/bin/black")
    (define-key python-mode-map "\C-cb" 'python-black-buffer)
    (define-key python-mode-map "\C-cb" 'python-black-region))
#+END_SRC
** recentf
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :config
    (setq recentf-max-saved-items 500
          recentf-auto-cleanup "05:00am")
    (recentf-mode t))
#+END_SRC
** smart comment
#+begin_src emacs-lisp
  (use-package smart-comment
    :ensure t
    :bind ("M-;" . smart-comment))
#+end_src
** switch window
#+BEGIN_SRC emacs-lisp
  (use-package switch-window
    :ensure t
    :bind (
           ("C-x o" . switch-window)
           )
    :config
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-qwerty-shortcuts '("a" "s" "d" "f" "j" "k" "l" "w" "e" "i" "o"))
    (setq switch-window-minibuffer-shortcut ?z)
    )
#+END_SRC
** term
make line-mode the default for terms and allow bigger buffer size
#+BEGIN_SRC emacs-lisp
  (setq term-buffer-maximum-size 262144)
  (defun ava/default-term-line-mode (&ret ignore) (term-line-mode))
  (advice-add 'ansi-term :after #'ava/default-term-line-mode)
#+END_SRC
ansi-term defaults to bash
#+BEGIN_SRC emacs-lisp
(defvar my-term-shell "/bin/bash")
(defadvice ansi-term (before force-bash)
  (interactive (list my-term-shell)))
(ad-activate 'ansi-term)
#+END_SRC
start a remote term =https://www.emacswiki.org/emacs/AnsiTermHints#toc4=
#+BEGIN_SRC emacs-lisp
  (defun ava/raterm ()
    (interactive)
    (setq user (read-string "User: "))
    (setq host (read-string "Host: "))
    (setq term-ansi-buffer-name (concat "term " host))
    (setq term-ansi-buffer-name (generate-new-buffer-name term-ansi-buffer-name))
    (setq term-ansi-buffer-name (apply 'make-term term-ansi-buffer-name "ssh" nil (list (concat user "@" host))))
    (set-buffer term-ansi-buffer-name)
    (term-mode)
    (term-line-mode)
    (term-set-escape-char ?\C-x)
    (switch-to-buffer term-ansi-buffer-name)
    (insert "function set-eterm-dir { \n echo -e \"\\033AnSiTu\" \"$LOGNAME\" \n echo -e \"\\033AnSiTc\" \"$(pwd)\" \n echo -e \"\\033AnSiTh\" \"$(hostname -f)\" \n history -a \n }")
    (insert "\nPROMPT_COMMAND=set-eterm-dir\n")
    (term-send-input))
#+END_SRC
start a few common terms
#+BEGIN_SRC emacs-lisp
  (defun ava/start-ansi-terms ()
    "Start a few common ansi terms"
    (interactive)
    (let ((term-start-helper (lambda (name cmd)
                               (ansi-term "/bin/bash" (format "bash.%s" name))
                               (with-current-buffer (format "*bash.%s*" name)
                                 (insert (format "%s\n" cmd))
                                 (term-send-input)))))
      (save-window-excursion
        ;only shells for now
        (funcall term-start-helper "rand0" "")
        (funcall term-start-helper "rand1" "")
        (funcall term-start-helper "rand2" ""))))
#+END_SRC
** transpose frame
#+BEGIN_SRC emacs-lisp
  (use-package transpose-frame
    :ensure t
    :bind (
           ("C-x |" . rotate-frame-clockwise)
           ("C-x \\" . rotate-frame-anticlockwise)
           )
    )
#+END_SRC
** undo-tree
A better non-linear undo
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :config
    (setq
     undo-tree-enable-undo-in-region nil
     undo-tree-visualizer-diff t
     undo-tree-visualizer-timestamps t
     undo-tree-incompatible-major-modes '(term-mode vterm-mode))
    (global-undo-tree-mode))
#+END_SRC
** vlf
use for opening files larger than =large-file-warning-threshold=
#+BEGIN_SRC emacs-lisp
  (use-package vlf
    :ensure t
    :custom
    (vlf-save-in-place t)
    :config
    (require 'vlf-setup))
#+END_SRC
** vterm
#+BEGIN_SRC emacs-lisp
    (use-package vterm
      :ensure t
      :config
      (setq vterm-max-scrollback 100000)
      (define-key vterm-mode-map (kbd "C-c C-j") 'vterm-copy-mode))
#+END_SRC
start a remote vterm
#+BEGIN_SRC emacs-lisp
  (defun ava/rvterm (hos)
    "Start a dir-tracking vterm on hos (or host at point if host is nil)"
    (interactive "P")
    (let* ((host (or hos (thing-at-point 'sexp)))
           (user (getenv "USER"))
           (bname (format "*vterm %s*" host)))
      (vterm bname)
      (switch-to-buffer bname)
      (let* ((inhibit-read-only t)
             (sshcmd (format "ssh %s@%s" user host))
             (fn1cmd "function vterm_printf() { \n printf \"\\e]%s\\e\\\\\" \"$1\" \n}")
             (fn2cmd "function vterm_prompt_end() { \n vterm_printf \"51;A$(whoami)@$(hostname):$(pwd)\" \n }")
             (ps1cmd "PS1=$PS1\'\\[$(vterm_promt_end)\\]\'")
             (bigcmd (format "%s\n%s\n%s\n%s\n" sshcmd fn1cmd fn2cmd ps1cmd)))
        (vterm-send-string bigcmd t))))
#+END_SRC
start a few common vterms
#+BEGIN_SRC emacs-lisp
  (defun ava/start-vterms ()
    "Start a few common vterms"
    (interactive)
    (let ((vterm-start-helper (lambda (name cmd)
                                (let ((bname (format "*vterm %s*" name)))
                                  (if (eq nil (get-buffer bname))
                                      (progn
                                        (vterm bname)
                                        (with-current-buffer bname
                                          (let ((inhibit-read-only t))
                                            (vterm-send-string (format "%s\n" cmd) t)))))))))
      (save-window-excursion
        (funcall vterm-start-helper "rand2" "")
        (funcall vterm-start-helper "rand1" "")
        (funcall vterm-start-helper "rand0" ""))))
#+END_SRC
** webjump
#+begin_src emacs-lisp
  (use-package webjump
    :bind (("C-c j" . webjump))
    :config
    (setq webjump-sites '(("Emacs Wiki" . [simple-query "www.emacswiki.org" "www.emacswiki.org/cgi-bin/wiki/" ""])
                          ("DuckDuckGo" .  [simple-query "duckduckgo.com" "duckduckgo.com/?q=" ""])
                          ("Google" .  [simple-query "www.google.com" "www.google.com/search?q=" ""])
                          ("Google Maps" . [simple-query "www.google.com/maps" "www.google.com/maps/search/" ""])
                          ("Wikipedia" .  [simple-query "wikipedia.org" "wikipedia.org/wiki/" ""])
                          ("AUR" . [simple-query "https://aur.archlinux.org" "https://aur.archlinux.org/packages/?O=0&K=" ""]))))
#+end_src
** which key
show options for bindings in realtime
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :init
    (which-key-mode))
#+END_SRC
** wrap region
automatically encloses double quotes or parens
#+BEGIN_SRC emacs-lisp
(use-package wrap-region
  :ensure t
  :config (wrap-region-global-mode t)
  :diminish wrap-region-mode)
#+END_SRC
** yasnippet
#+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :ensure t
      :diminish yas-minor-mode
      :commands (yas-minor-mode)
      :init
      (progn
        (add-hook 'ess-r-mode-hook #'yas-minor-mode)
        (add-hook 'python-mode-hook #'yas-minor-mode)
        (add-hook 'lisp-interaction-mode-hook #'yas-minor-mode)
        (add-hook 'emacs-lisp-mode-hook #'yas-minor-mode)
        (add-hook 'c++-mode-hook #'yas-minor-mode)
        (add-hook 'c-mode-hook #'yas-minor-mode))
      :config
      (use-package yasnippet-snippets
        :ensure t)
      (yas-reload-all))
#+END_SRC
** ztree
nice directory level diffing
#+BEGIN_SRC emacs-lisp
  (use-package ztree
    :ensure t
    :commands ztree-diff
    :bind (:map ztree-mode-map
                ("j" . ztree-jump-side)))
#+END_SRC
* inactive packages
** dmenu
to launch applications from exwm (not in use)
#+BEGIN_SRC emacs-lisp
;;(use-package dmenu
;;  :ensure t
;;  :bind
;;  ("s-SPC" . dmenu))
#+END_SRC
** dumb jump
Like a cached/simplified form of TAGS without dependencies
Disable post xref change...
#+BEGIN_SRC emacs-lisp
;  (use-package dumb-jump
;    :disabled
;    :ensure t
;    :bind
;    (("C-c j" . dumb-jump-go))
;    :config
;    (setq dumb-jump-selector 'helm
;          dumb-jump-confirm-jump-to-modified-file nil))
#+END_SRC
** eaf
Disabled as not snappy enough
[[https://aur.archlinux.org/packages/emacs-eaf/][emacs-eaf AUR]]
[[https://github.com/manateelazycat/emacs-application-framework][github]]
#+BEGIN_SRC emacs-lisp
;  (use-package eaf
;    :load-path "/usr/share/emacs/site-lisp/eaf"
;    :custom
;    (eaf-find-alternate-file-in-dired t)
;    (browse-url-browser-function 'eaf-open-browser)
;    :config
;    (eaf-setq eaf-pdf-default-zoom 1.25)
;    (eaf-setq eaf-browser-enable-adblocker "true")
;    (eaf-bind-key nil "SPC" eaf-browser-keybinding)
;    (eaf-bind-key nil "p" eaf-browser-keybinding)
;    (defun adviser-find-file (orig-fn file &rest args)
;      (let ((fn (if (commandp 'eaf-open) 'eaf-open orig-fn)))
;        (pcase (file-name-extension file)
;          ("pdf"  (apply fn file nil))
;          ("epub" (apply fn file nil))
;          (_      (apply orig-fn file args)))))
;    (advice-add #'find-file :around #'adviser-find-file))
#+END_SRC
** elfeed
#+BEGIN_SRC emacs-lisp
;  (use-package elfeed
;    :disabled
;    :ensure   t
;    :commands elfeed
;    :config
;    (setq-default elfeed-search-filter "@1-week-ago ")
;    (setq elfeed-feeds
;          '(("https://www.archlinux.org/feeds/news/" arch)
;            ("http://www.reddit.com/r/emacs/.rss" emacs reddit)
;            ("http://sachachua.com/blog/category/emacs-news/feed" emacs sacha)
;            ("http://endlessparentheses.com/atom.xml" emacs)
;            ("http://www.masteringemacs.org/feed/" emacs)
;            ("http://emacs-fu.blogspot.com/feeds/posts/default" emacs)
;            ("http://emacsredux.com/atom.xml" emacs)
;            ("http://arxiv.org/rss/q-fin.TR" arxiv trading)
;            ("http://feeds.feedburner.com/zerohedge/feed"))
;            )
;    )
#+END_SRC
** exwm
comment out for now as not in use
#+BEGIN_SRC emacs-lisp
  ;;(use-package exwm :ensure t
  ;;  :init
  ;;  :config
  ;;  (setq exwm-workspace-number 4)
  ;;  (defun exwm-rename-buffer-to-title () (exwm-workspace-rename-buffer exwm-title))
  ;;  (add-hook 'exwm-update-title-hook 'exwm-rename-buffer-to-title)
  ;;  (exwm-input-set-key (kbd "s-r") #'exwm-reset)
  ;;  (exwm-input-set-key (kbd "s-w") #'exwm-workspace-switch)
  ;;  (dotimes (i 10)
  ;;    (exwm-input-set-key (kbd (format "s-%d" i))
  ;;                        `(lambda ()
  ;;                           (interactive)
  ;;                           (exwm-workspace-switch-create ,i))))
  ;;  (exwm-input-set-key (kbd "s-&")
  ;;                      (lambda (command)
  ;;                        (interactive (list (read-shell-command "$ ")))
  ;;                        (start-process-shell-command command nil command)))
  ;;  (setq exwm-input-simulation-keys
  ;;        '(([?\C-b] . [left])
  ;;          ([?\C-f] . [right])
  ;;          ([?\C-p] . [up])
  ;;          ([?\C-n] . [down])
  ;;          ([?\C-a] . [home])
  ;;          ([?\C-e] . [end])
  ;;          ([?\M-v] . [prior])
  ;;          ([?\C-v] . [next])
  ;;          ([?\C-d] . [delete])
  ;;          ([?\C-k] . [S-end delete])
  ;;          ([?\C-s] . [?\C-f])
  ;;          ([?\C-t] . [?\C-n])))
  ;;  (exwm-enable)
  ;;  )
#+END_SRC
** fancy narrow
replaces default narrow (slow so not in use)
#+BEGIN_SRC emacs-lisp
;  (use-package fancy-narrow
;    :ensure t
;    :init
;    (fancy-narrow-mode)
;    :diminish fancy-narrow-mode)
#+END_SRC
** irony
Also run ~M-x irony-install-server~ which just needs cmake, libclang, and llvm libs
Disabled in favor of trying LSP
#+BEGIN_SRC emacs-lisp
;    (use-package irony
;      :disabled
;      :ensure t
;      :init
;      (add-hook 'c++-mode-hook 'irony-mode)
;      (add-hook 'c-mode-hook 'irony-mode)
;      (add-hook 'objc-mode-hook 'irony-mode)
;      (setq-default irony-cdb-compilation-databases '(irony-cdb-libclang
;                                                      irony-cdb-json
;                                                      irony-cdb-clang-complete))
;      :bind (:map irony-mode-map
;                  ("C-c t" . irony-get-type))
;      :config
;      (defun ava/irony-mode-hook ()
;        (define-key irony-mode-map [remap completion-at-point]
;          'irony-completion-at-point-async)
;        (define-key irony-mode-map [remap complete-symbol]
;          'irony-completion-at-point-async))
;      (add-hook 'irony-mode-hook 'ava/irony-mode-hook)
;      (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
;      (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)
;      (add-hook 'irony-mode-hook #'irony-eldoc)
;      (use-package irony-eldoc
;        :ensure t))
#+END_SRC
** leetcode
on MELPA from here [[https://github.com/kaiwk/leetcode][leetcode]]
#+BEGIN_SRC emacs-lisp
;  (use-package leetcode
;    :disabled
;    :ensure t
;    :config
;    (setq leetcode-prefer-language "cpp")
;    (setq leetcode-prefer-sql "mysql"))
#+END_SRC
** mu4e
The smtp portion will require app specific password and will store it in ~/.authinfo after first use
#+BEGIN_SRC emacs-lisp
  ;; (use-package mu4e
  ;;   :load-path "/usr/share/emacs/site-lisp/mu4e"
  ;;   :config
  ;;   (setq mu4e-maildir (expand-file-name "~/mbsync"))
  ;;   (setq mu4e-sent-folder "/sent")
  ;;   (setq mu4e-drafts-folder "/drafts")
  ;;   (setq mu4e-trash-folder "/trash")

  ;;   ;;GMail/IMAP takes care of this
  ;;   (setq mu4e-sent-messages-behavior 'delete)
  ;;   (setq mu4e-get-mail-command "mbsync -q gmail")
  ;;   (setq mu4e-update-interval 3600)
  ;;   (setq mu4e-maildir-shortcuts
  ;;   '(("/INBOX" . ?i)
  ;;     ("/sent" . ?s)))
  ;;   (setq mu4e-view-show-images t)
  ;;   (setq mu4e-use-fancy-chars t)
  ;;   (setq mu4e-view-show-addresses t)
  ;;   (setq mu4e-headers-show-threads nil)
  ;;   )
  ;; (require 'smtpmail)
  ;; (setq message-send-mail-function 'smtpmail-send-it
  ;;       user-mail-address "email_username@gmail.com"
  ;;       smtpmail-smtp-user "email_username"
  ;;       smtpmail-local-domain "gmail.com"
  ;;       smtpmail-default-smtp-server "smtp.gmail.com"
  ;;       smtpmail-smtp-server "smtp.gmail.com"
  ;;       smtpmail-smtp-service 587)
#+END_SRC
** rmsbolt
#+BEGIN_SRC emacs-lisp
;  (use-package rmsbolt
;    :disabled
;    :ensure t)
#+END_SRC
** speed typing
#+BEGIN_SRC emacs-lisp
;  (use-package speed-type
;    :ensure t
;    :disabled
;    :commands (speed-type-text))
#+END_SRC
** telega
Telegram support from emacs (needs visual-fill-column)
#+BEGIN_SRC emacs-lisp
  (use-package visual-fill-column :ensure t)
#+END_SRC
#+BEGIN_SRC emacs-lisp
;      (require 'notifications)
;      (use-package telega
;        :disabled
;        :load-path "~/3rdParty/telega/"
;        :commands (telega)
;        :config
;        (setq telega-use-notifications t)
;        (add-hook 'telega-chat-mode-hook (lambda ()
;                                           (setq company-backends '(telega-company-emoji))
;                                           (company-mode 1)))
;        :defer t)
#+END_SRC
