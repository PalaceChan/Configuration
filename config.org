* startup
** init and gc
As early as possible do this
#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold (* 1000 1024 1024))
  (defvar file-name-handler-alist-original file-name-handler-alist)
  (setq file-name-handler-alist nil)
#+END_SRC
manage gc and restore the above after startup
#+BEGIN_SRC emacs-lisp
  (defvar better-gc-cons-threshold (* 100 1024 1024) ; 100M
    "The default value to use for `gc-cons-threshold'.")

  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold better-gc-cons-threshold)
              (setq file-name-handler-alist file-name-handler-alist-original)
              (makunbound 'file-name-handler-alist-original)))

  (add-hook 'emacs-startup-hook
            (lambda ()
              (if (boundp 'after-focus-change-function)
                  (add-function :after after-focus-change-function
                                (lambda ()
                                  (unless (frame-focus-state)
                                    (garbage-collect))))
                (add-hook 'after-focus-change-function 'garbage-collect))
              (defun gc-minibuffer-setup-hook ()
                (setq gc-cons-threshold (* better-gc-cons-threshold 10)))

              (defun gc-minibuffer-exit-hook ()
                (garbage-collect)
                (setq gc-cons-threshold better-gc-cons-threshold))

              (add-hook 'minibuffer-setup-hook #'gc-minibuffer-setup-hook)
              (add-hook 'minibuffer-exit-hook #'gc-minibuffer-exit-hook)))
#+END_SRC
** theme
#+BEGIN_SRC emacs-lisp
(use-package doom-themes :ensure t :defer t)
(load-theme 'doom-one t)
(set-frame-font "Inconsolata-13")
(global-font-lock-mode t)
(setq font-lock-maximum-decoration t)
#+END_SRC
** start
Disable a bunch of visuals
#+BEGIN_SRC emacs-lisp
(menu-bar-mode 0)
(tool-bar-mode 0)
(scroll-bar-mode 0)
(transient-mark-mode 1)
#+END_SRC
Disable startup messages and text in scratch
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t
  inhibit-startup-echo-area-message t
  initial-scratch-message nil)
#+END_SRC
** warnings
Disable common warnings
#+BEGIN_SRC emacs-lisp
(put 'set-goal-column 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'erase-buffer 'disabled nil)
(put 'downcase-region 'disabled nil)
(setq large-file-warning-threshold (* 120 1024 1024))
#+END_SRC
** basic settings
#+BEGIN_SRC emacs-lisp
  (setq scroll-step 1
        scroll-margin 3
        scroll-conservatively 9999
        scroll-preserve-screen-position t
        grep-highlight-matches t
        shell-file-name "bash"
        x-alt-keysym 'meta
        kill-ring-max 100
        undo-outer-limit 50000000
        make-backup-files nil
        browse-url-browser-function 'eww-browse-url
        calendar-mode-line-format nil
        set-mark-command-repeat-pop t)

  (show-paren-mode t)
  (add-to-list 'same-window-buffer-names "*Buffer List*")
  (add-to-list 'same-window-buffer-names "*grep*")
#+END_SRC
** save place
#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :config (save-place-mode))
#+END_SRC
** save history
Save some history across sessions. (savehist-mode) on auto-save can be slow so we rely on desktop-save instead
#+BEGIN_SRC emacs-lisp
  (setq history-length 800)
  (setq history-delete-duplicates t)
  (desktop-save-mode -1)
  (setq desktop-globals-to-save
        (append
         '(desktop-missing-file-waning
           (shell-command-history 800)
           tags-file-name tags-table-list
           (search-ring . 800) (regexp-search-ring . 800)
           register-alist file-name-history (kill-ring . 8000)
           (minibuffer-history . 800) query-replace-history regexp-history)))
#+END_SRC
** mode bar
show battery, column number and nicely formatted time
#+BEGIN_SRC emacs-lisp
(setq column-number-mode t)
(setq display-time-24hr-format t)
(setq display-time-format "%H:%M - %Y%m%d")
(display-battery-mode t)
(display-time-mode 1)
(size-indication-mode t)
#+END_SRC
** highlighting
#+BEGIN_SRC emacs-lisp
(global-hi-lock-mode 1)
(setq hi-lock-auto-select-face t)
#+END_SRC
** emacs server
#+BEGIN_SRC emacs-lisp
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+END_SRC
** misc
override default timezones for the world clock view
#+BEGIN_SRC emacs-lisp
(setq display-time-world-list '(
                                ("America/Chicago" "Chicago") ("Asia/Tokyo" "Japan")
                                ("Europe/Berlin" "Frankfurt") ("Australia/Sydney" "Australia") ))
#+END_SRC
winner mode enabled to pop a stack of window configurations
#+BEGIN_SRC emacs-lisp
  (use-package winner
    :bind (("M-N" . winner-redo)
           ("M-P" . winner-undo))
    :config
    (winner-mode 1))
#+END_SRC
aliases and global bindings
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
(global-set-key (kbd "C-x l") 'align-regexp)
#+END_SRC
kill current buffer no prompt
#+BEGIN_SRC emacs-lisp
(defun kill-current-buffer ()
  "Kill the current buffer, without confirmation."
  (interactive)
  (kill-buffer (current-buffer)))
(global-set-key "\C-xk" 'kill-current-buffer)
#+END_SRC
replace zap-to-char with superior zap-up-to-char
#+BEGIN_SRC emacs-lisp
  (global-set-key "\M-z" 'zap-up-to-char)
  (global-set-key "\M-Z" (lambda (char)
                           (interactive "cZap back to char: ")
                           (zap-up-to-char -1 char)))
#+END_SRC
* auto package updating
stay up to date
#+BEGIN_SRC emacs-lisp
  (use-package auto-package-update
    :ensure t
    :if (not (daemonp))
    :custom
    (auto-package-update-interval 90)
    (auto-package-update-prompt-before-update t)
    (auto-package-update-delete-old-versions t)
    (auto-package-update-hide-results t)
    :config
    (auto-package-update-maybe))
#+END_SRC
* term
make line-mode the default for terms and allow bigger buffer size
#+BEGIN_SRC emacs-lisp
  (setq term-buffer-maximum-size 262144)
  (defun ava/default-term-line-mode (&ret ignore) (term-line-mode))
  (advice-add 'ansi-term :after #'ava/default-term-line-mode)
#+END_SRC
ansi-term defaults to bash
#+BEGIN_SRC emacs-lisp
(defvar my-term-shell "/bin/bash")
(defadvice ansi-term (before force-bash)
  (interactive (list my-term-shell)))
(ad-activate 'ansi-term)
#+END_SRC
start a remote term =https://www.emacswiki.org/emacs/AnsiTermHints#toc4=
#+BEGIN_SRC emacs-lisp
  (defun ava/remote-term ()
    (interactive)
    (setq user (read-string "User: "))
    (setq host (read-string "Host: "))
    (setq term-ansi-buffer-name (concat "term " host))
    (setq term-ansi-buffer-name (generate-new-buffer-name term-ansi-buffer-name))
    (setq term-ansi-buffer-name (apply 'make-term term-ansi-buffer-name "ssh" nil (list (concat user "@" host))))
    (set-buffer term-ansi-buffer-name)
    (term-mode)
    (term-line-mode)
    (term-set-escape-char ?\C-x)
    (switch-to-buffer term-ansi-buffer-name)
    (insert "function set-eterm-dir { \n echo -e \"\\033AnSiTu\" \"$LOGNAME\" \n echo -e \"\\033AnSiTc\" \"$(pwd)\" \n echo -e \"\\033AnSiTh\" \"$(hostname -f)\" \n history -a \n }")
    (insert "\nPROMPT_COMMAND=set-eterm-dir\n")
    (term-send-input))
#+END_SRC
start a few common terms
#+BEGIN_SRC emacs-lisp
  (defun ava/start-ansi-terms ()
    "Start a few common ansi terms"
    (interactive)
    (let ((term-start-helper (lambda (name cmd)
                               (ansi-term "/bin/bash" (format "bash.%s" name))
                               (with-current-buffer (format "*bash.%s*" name)
                                 (insert (format "%s\n" cmd))
                                 (term-send-input)))))
      (save-window-excursion
        ;only main shell for now
        (funcall term-start-helper "main" ""))))
#+END_SRC
* development
** general
#+BEGIN_SRC emacs-lisp
(setq indent-tabs-mode nil)
(setq tab-width 4)
#+END_SRC
** tags
generation of TAGS covered by =scripts/updateTagsAndDb.py= on [[https://github.com/PalaceChan/][GitHub]]
#+BEGIN_SRC emacs-lisp
(setq tags-file-name "~/rabbit/tags/TAGS")
#+END_SRC
** semantic mode
use semantic without it interfering with completion and without auto-parsing in idle time
(only use it for helm-semantic-or-imenu and thus parses buffer on demand)
#+BEGIN_SRC emacs-lisp
  (require 'semantic)
  (add-hook 'semantic-mode-hook
            (lambda ()
              (dolist (x (default-value 'completion-at-point-functions))
                (when (string-prefix-p "semantic-" (symbol-name x))
                  (remove-hook 'completion-at-point-functions x)))))
  (setq semantic-default-submodes '(global-semanticdb-minor-mode))
  (semantic-mode 1)
#+END_SRC
** c/c++
indentation related
#+BEGIN_SRC emacs-lisp
(setq c-default-style "linux"
      c-basic-offset 4)
(c-set-offset 'innamespace 0)
#+END_SRC
toggle between implementation and header
#+BEGIN_SRC emacs-lisp
(setq cc-search-directories
'( "/usr/include" "/usr/include/sys" "/usr/include/linux"
   "."
  )
)
(setq cc-other-file-alist
'(("\\.cpp$" (".h" ".hpp"))
("\\.h$" (".cpp" ".c"))
("\\.hpp$" (".cpp" ".c"))
("\\.C$" (".H"))
("\\.H$" (".C"))
))
(add-hook 'c-mode-common-hook (lambda() (global-set-key (kbd "C-c o") 'ff-find-other-file)))
#+END_SRC

** compilation
#+BEGIN_SRC emacs-lisp
  (setq compile-command "make"
        compilation-scroll-output t
        compilation-read-command nil)
#+END_SRC
** merging
ediff settings
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'ediff
    (setq
     ediff-window-setup-function #'ediff-setup-windows-plain
     ediff-split-window-function #'split-window-horizontally
     ediff-grab-mouse nil))
#+END_SRC
* undo-tree
A better non-linear undo
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :config
    (setq   
     undo-tree-enable-undo-in-region nil
     undo-tree-visualizer-diff t
     undo-tree-visualizer-timestamps t)
    (global-undo-tree-mode))
#+END_SRC
* exwm
comment out for now as not in use
#+BEGIN_SRC emacs-lisp
  ;;(use-package exwm :ensure t
  ;;  :init
  ;;  :config
  ;;  (setq exwm-workspace-number 4)
  ;;  (defun exwm-rename-buffer-to-title () (exwm-workspace-rename-buffer exwm-title))
  ;;  (add-hook 'exwm-update-title-hook 'exwm-rename-buffer-to-title)
  ;;  (exwm-input-set-key (kbd "s-r") #'exwm-reset)
  ;;  (exwm-input-set-key (kbd "s-w") #'exwm-workspace-switch)
  ;;  (dotimes (i 10)
  ;;    (exwm-input-set-key (kbd (format "s-%d" i))
  ;;                        `(lambda ()
  ;;                           (interactive)
  ;;                           (exwm-workspace-switch-create ,i))))
  ;;  (exwm-input-set-key (kbd "s-&")
  ;;                      (lambda (command)
  ;;                        (interactive (list (read-shell-command "$ ")))
  ;;                        (start-process-shell-command command nil command)))
  ;;  (setq exwm-input-simulation-keys
  ;;        '(([?\C-b] . [left])
  ;;          ([?\C-f] . [right])
  ;;          ([?\C-p] . [up])
  ;;          ([?\C-n] . [down])
  ;;          ([?\C-a] . [home])
  ;;          ([?\C-e] . [end])
  ;;          ([?\M-v] . [prior])
  ;;          ([?\C-v] . [next])
  ;;          ([?\C-d] . [delete])
  ;;          ([?\C-k] . [S-end delete])
  ;;          ([?\C-s] . [?\C-f])
  ;;          ([?\C-t] . [?\C-n])))
  ;;  (exwm-enable)
  ;;  )
#+END_SRC
* dmenu
to launch applications from exwm (not in use)
#+BEGIN_SRC emacs-lisp
;;(use-package dmenu
;;  :ensure t
;;  :bind
;;  ("s-SPC" . dmenu))
#+END_SRC
* recentf
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :config
    (setq recentf-max-saved-items 500
          recentf-auto-cleanup "05:00am")
    (recentf-mode t))
#+END_SRC
* helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
               :demand t
               :diminish helm-mode
               :init
               (progn
                 (require 'helm-config)
                 (setq helm-candidate-number-limit 100)
                 (setq helm-idle-delay 0.0
                       helm-input-idle-delay 0.01
                       helm-yas-display-key-on-candidate t
                       helm-quick-update t
                       helm-M-x-requires-pattern nil)
                 (helm-mode)
                 )
               :bind (
                      ("C-h a" . helm-apropos)
                      ("C-x C-b" . helm-buffers-list)
                      ("C-x b" . helm-mini)
                      ("M-y" . helm-show-kill-ring)
                      ("M-x" . helm-M-x)
                      ("C-x C-f" . helm-find-files)
                      ("C-c h o" . helm-occur)
                      ("C-c h r" . helm-register)
                      ("C-c h b" . helm-resume)
                      ("C-c h i" . helm-semantic-or-imenu)
                      ("C-c h m" . helm-man-woman)
                      ("C-c h I" . helm-imenu-in-all-buffers)
                      ("C-c h l" . helm-locate)
                      ("C-c h <SPC>" . helm-all-mark-rings)
                      )
               :config
               (setq helm-command-prefix-key "C-c h")
               (setq helm-autoresize-min-height 25)
               (setq helm-autoresize-max-height 25)
               (setq helm-split-window-in-side-p t
                     helm-move-to-line-cycle-in-source t
                     helm-ff-search-library-in-sexp t
                     helm-scroll-amount 8
                     helm-ff-file-name-history-use-recentf t)
               (setq helm-buffer-max-length nil)
               ;;locate %s -d FOO -e --regex %s where FOO is : delimited from cmd updatedb -l 0 -o i.db -U path_i for all paths
               ;;(defvar my-locate-db-command (with-temp-buffer (insert-file-contents "path/to/cmd.txt") (buffer-string)))
               ;;(setq helm-locate-command my-locae-db-command)
               (helm-mode 1)
               (helm-autoresize-mode 1)
               (define-key  helm-map (kbd "<tab>") 'helm-execute-persistent-action)
               (define-key  helm-map (kbd "C-i") 'helm-execute-persistent-action)
               (define-key  helm-map (kbd "C-z") 'helm-select-action)
               (defun ava/around-helm-buffers-sort-transformer (candidates source)
                 candidates)
               (advice-add 'helm-buffers-sort-transformer
                           :override #'ava/around-helm-buffers-sort-transformer)
               :ensure helm)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package helm-swoop
    :ensure t
    :bind (("C-c h s" . helm-multi-swoop))
    :init
    (bind-key "M-i" 'helm-swoop-from-isearch isearch-mode-map)
    :config
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-current-mode-from-helm-swoop))

  (use-package helm-ag :ensure t)
  (use-package helm-rg :ensure t)
#+END_SRC

remap =term-previous-matching-input= to a helm frontend
#+BEGIN_SRC emacs-lisp
  (use-package helm-shell-history
    :load-path "~/.emacs.d/lisp/helm-shell-history"
    :after term
    :config
    (setq helm-shell-history-file "~/.bash_eternal_history")
    (setq helm-shell-history-fuzzy-match t)
    (setq helm-shell-history-fast-parser "~/development/helm-shell-history/src/parse_history")
    (define-key term-mode-map (kbd "M-r") 'helm-shell-history))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package helm-descbinds
    :ensure t
    :init (helm-descbinds-mode))
#+END_SRC
* avy
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind (("M-g c" . avy-goto-char-timer)
           ("M-g M-g" . avy-goto-line))
    :config
    (setq avy-timeout-seconds 0.3)
    (when (display-graphic-p) (setq avy-background t)))
#+END_SRC
* switch window
#+BEGIN_SRC emacs-lisp
  (use-package switch-window
    :ensure t
    :bind (
           ("C-x o" . switch-window)
           )
    :config
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-qwerty-shortcuts '("a" "s" "d" "f" "j" "k" "l" "w" "e" "i" "o"))
    (setq switch-window-minibuffer-shortcut ?z)
    )
#+END_SRC
* dumb jump
Like a cached/simplified form of TAGS without dependencies
#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :ensure t
    :bind
    (("C-c j" . dumb-jump-go))
    :config
    (setq dumb-jump-selector 'helm
          dumb-jump-confirm-jump-to-modified-file nil))
#+END_SRC
* company
** company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (setq company-idle-delay 0.1
          company-minimum-prefix-length 1
          company-require-match nil
          company-show-numbers t
          company-tooltip-limit 20
          company-tooltip-align-annotations t
          company-global-modes '(not compilation-mode magit-status-mode)
          company-backends '(company-clang company-capf company-files ;company-semantic <-- slow
                                           (company-dabbrev-code company-gtags company-etags company-keywords)
                                           company-dabbrev))
    (define-key company-mode-map (kbd "C-:") 'company-complete-common)
    (global-company-mode 1))
#+END_SRC
** posframe
A much nicer frame for completion candidates
#+BEGIN_SRC emacs-lisp
  (use-package company-posframe
    :ensure t
    :config
    (company-posframe-mode 1))
#+END_SRC
** helm company
#+BEGIN_SRC emacs-lisp
    (use-package helm-company
      :ensure t
      :config
      (define-key company-mode-map (kbd "C-:") 'helm-company))
#+END_SRC
** company-shell
backend for shells
#+BEGIN_SRC emacs-lisp
  (use-package company-shell
    :ensure t
    :after company
    :config
    (add-to-list 'company-shell-modes 'term-mode)
    (add-hook
     'term-mode-hook (lambda ()
                       (set (make-local-variable 'company-idle-delay) 1.0)
                       (set (make-local-variable 'company-minimum-prefix-length) 2)
                       (set (make-local-variable 'company-backends)
                            '((company-files company-shell company-shell-env) company-dabbrev)))))
#+END_SRC
* irony
Also run ~M-x irony-install-server~ which just needs cmake, libclang, and llvm libs
#+BEGIN_SRC emacs-lisp
    (use-package irony
      :disabled
      :ensure t
      :init
      (add-hook 'c++-mode-hook 'irony-mode)
      (add-hook 'c-mode-hook 'irony-mode)
      (add-hook 'objc-mode-hook 'irony-mode)
      (setq-default irony-cdb-compilation-databases '(irony-cdb-libclang
                                                      irony-cdb-json
                                                      irony-cdb-clang-complete))
      :bind (:map irony-mode-map
                  ("C-c t" . irony-get-type))
      :config
      (defun ava/irony-mode-hook ()
        (define-key irony-mode-map [remap completion-at-point]
          'irony-completion-at-point-async)
        (define-key irony-mode-map [remap complete-symbol]
          'irony-completion-at-point-async))
      (add-hook 'irony-mode-hook 'ava/irony-mode-hook)
      (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
      (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)
      (add-hook 'irony-mode-hook #'irony-eldoc)
      (use-package irony-eldoc
        :ensure t))
#+END_SRC
* yasnippet
#+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :ensure t
      :diminish yas-minor-mode
      :commands (yas-minor-mode)
      :init
      (progn 
        (add-hook 'ess-r-mode-hook #'yas-minor-mode)
        (add-hook 'python-mode-hook #'yas-minor-mode)
        (add-hook 'lisp-interaction-mode-hook #'yas-minor-mode)
        (add-hook 'emacs-lisp-mode-hook #'yas-minor-mode)
        (add-hook 'c++-mode-hook #'yas-minor-mode)
        (add-hook 'c-mode-hook #'yas-minor-mode))
      :config
      (use-package yasnippet-snippets
        :ensure t)
      (yas-reload-all))
#+END_SRC
* org
use bullet mode
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+END_SRC
now configure org (default installed)
#+BEGIN_SRC emacs-lisp
    (setq org-use-speed-commands 1)
    (setq org-list-description-max-indent 5)
    (setq org-export-html-postamble nil)
    (setq org-log-done 'note)
    (setq org-cycle-separator-lines 0)
    (setq org-deadline-warning-days 7)

    (add-hook 'org-mode-hook 'org-indent-mode)

    (setq org-confirm-babel-evaluate nil)
    (org-babel-do-load-languages 'org-babel-load-languages '( (emacs-lisp . t) (shell . t) (R . t) ))

    (global-set-key (kbd "C-c a") 'org-agenda)
    (setq org-agenda-files (quote ("~/todo.org")))
    (setq org-agenda-window-setup (quote current-window))

    (define-key global-map (kbd "C-c l") 'org-store-link)
    (define-key global-map (kbd "C-c c") 'org-capture)
    (setq org-capture-templates 
          '(("t" "Todo" entry (file+headline "~/todo.org" "Tasks")
             "* TODO %?")
            ("l" "Link" entry (file+headline "~/todo.org" "Links")
             "* %^L %? %^g")))
#+END_SRC
* dired related
#+BEGIN_SRC emacs-lisp  
  (with-eval-after-load 'dired
    (require 'dired-x)
    (setq 
     dired-recursive-copies 'always
     dired-recursive-deletes 'always
     dired-dwim-target t
     dired-auto-revert-buffer 'dired-directory-changed-p
     dired-listing-switches "-Al --si --time-style long-iso --group-directories-first"))
#+END_SRC
a much nicer dired (can in-place expand subdirectory contents)
#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
             :config
             (define-key dired-mode-map "i" 'dired-subtree-insert)
             (define-key dired-mode-map ";" 'dired-subtree-remove)
             :ensure dired-subtree)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package dired-git-info
    :disabled
    :ensure t
    :bind (:map dired-mode-map (")" . dired-git-info-mode))
    :config
    (setq dgi-commit-message-format "%f\t%an\t%cr"))
#+END_SRC
* ztree
nice directory level diffing
#+BEGIN_SRC emacs-lisp
  (use-package ztree
    :ensure t
    :commands ztree-diff
    :bind (:map ztree-mode-map
                ("j" . ztree-jump-side)))
#+END_SRC
* wrap region
automatically encloses double quotes or parens
#+BEGIN_SRC emacs-lisp
(use-package wrap-region
  :ensure t
  :config (wrap-region-global-mode t)
  :diminish wrap-region-mode)
#+END_SRC
* expand region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :commands er/expand-region
    :bind ("C-=" . er/expand-region)
    )
#+END_SRC
* iedit
#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure t
    :bind ("C-;" . iedit-mode)
    :config
    (setq iedit-toggle-key-default nil)
    (define-key iedit-mode-occurrence-keymap (kbd "RET") 'iedit-mode)
    :diminish)
#+END_SRC
* multiple cursors
the hydra here [[http://ivanmalison.github.io/dotfiles/][hydra-example]] not working well...
pull in phi-search as well to get incremental search while in mc
(protip: easy-kill ==C-SPC== will turn selection into region)
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :config
    (progn
      (use-package phi-search-mc
        :ensure t
        :config
        (phi-search-mc/setup-keys)))
    :bind (("C-c i e" . mc/mark-all-like-this)
           ("C-c i l" . mc/edit-lines)
           ("C-c i s" . mc/mark-all-in-region)
           ("C-c i r" . mc/mark-all-in-region-regexp)
           ("C-<"   . mc/mark-previous-like-this)
           ("C->"   . mc/mark-next-like-this)
           :map mc/keymap ("C-s" . phi-search)))
#+END_SRC
* easy kill
Use ~M-w~ and modifiers to more efficiently save things to kill ring
#+BEGIN_SRC emacs-lisp
  (use-package easy-kill
  :ensure t
  :config
  (global-set-key [remap kill-ring-save] #'easy-kill))
#+END_SRC
* fancy narrow
replaces default narrow (slow so not in use)
#+BEGIN_SRC emacs-lisp
;  (use-package fancy-narrow
;    :ensure t
;    :init
;    (fancy-narrow-mode)
;    :diminish fancy-narrow-mode)
#+END_SRC
* which key
show options for bindings in realtime
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :init
  (which-key-mode))
#+END_SRC
* transpose frame
#+BEGIN_SRC emacs-lisp
  (use-package transpose-frame
    :ensure t
    :bind (
           ("C-x |" . rotate-frame-clockwise)
           ("C-x \\" . rotate-frame-anticlockwise)
           )
    )
#+END_SRC
* hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure hydra
    :init
    (global-set-key
     (kbd "C-c g")
     (defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1)
                                           :hint nil)
       ("n" git-gutter:next-hunk "next hunk")
       ("p" git-gutter:previous-hunk "previous hunk")
       ("h" (progn (goto-char (point-min)) (git-gutter:next-hunk 1)) "first hunk")
       ("l" (progn (goto-char (point-min)) (git-gutter:previous-hunk 1)) "last hunk")
       ("<SPC>" git-gutter:popup-hunk "popup hunk")
       ("s" git-gutter:stage-hunk "stage hunk")
       ("r" git-gutter:revert-hunk "revert hunk")
       ("q" nil "quit")))

    (global-set-key
     (kbd "C-c e")
     (defhydra hydra-paredit (:hint nil)
       ("f" paredit-forward-slurp-sexp "slurp-forward")
       ("F" paredit-forward-barf-sexp "barf-forward")
       ("b" paredit-backward-slurp-sexp "slurp-backward")
       ("B" paredit-backward-barf-sexp "barf-backward")
       ("n" paredit-foward "forward")
       ("p" paredit-backward "backward")
       ("r" paredit-raise-sexp "raise")
       ("s" paredit-splice-sexp "splice")
       ("u" undo-only "undo")
       ("q" nil "quit"))))
#+END_SRC
* magit
#+BEGIN_SRC emacs-lisp
(use-package magit 
:ensure t
:config
(setq magit-display-buffer-function #'magit-display-buffer-fullcolumn-most-v1)
:bind
("C-x g" . magit-status)
("C-c m" . magit-file-dispatch))
#+END_SRC
* git-timemachine
#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :ensure t)
#+END_SRC
* git-gutter
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :ensure t
    :init
    (global-git-gutter-mode +1))
#+END_SRC
* clang-format
#+BEGIN_SRC emacs-lisp
  (use-package clang-format
    :ensure t
    :commands clang-format-buffer clang-format-region
    :config
    ;(setq clang-format-executable "TODO")
    (define-key c++-mode-map "\C-cb" 'clang-format-buffer)
    (define-key c++-mode-map "\C-cb" 'clang-format-region))
#+END_SRC
* ess
#+BEGIN_SRC emacs-lisp
  (use-package ess
    :ensure t
    :init
    (require 'ess-site)
    :config
    (setq inferior-R-program-name "/usr/bin/R"
          inferior-R-args "--no-save"
          ess-eval-visibly-p nil
          ess-directory "~/"
          ess-use-flymake nil
          ess-indent-with-fancy-comments nil)
    ;http://stackoverflow.com/questions/780796/emacs-ess-mode-tabbing-for-comment-region
    (defun ava-ess-settings ()
      (setq ess-indent-with-fancy-comments nil))
    (add-hook 'ess-mode-hook #'ava-ess-settings)
    (define-key ess-r-mode-map "_" #'ess-insert-assign)
    (define-key inferior-ess-r-mode-map "_" #'ess-insert-assign))
#+END_SRC
* elpy
To use a venv set a pyvenv-activate directory local or file local variable to the venv path
#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :ensure t
    :commands elpy-enable
    :init
    (progn
      (elpy-enable)
      (setq elpy-modules
            '(elpy-module-sane-defaults
              elpy-module-highlight-indentation
              elpy-module-pyvenv
              elpy-module-yasnippet))
      (eval-after-load "elpy"
        '(cl-dolist (key '("C-<return>" "C-<up>" "C-<down>" "C-<left>" "C-<right>"))
           (define-key elpy-mode-map (kbd key) nil)))
      :config
      (setq python-shell-interpreter "jupyter")
      (setq python-shell-interpreter-args "console --simple-prompt")
      (setq elpy-rpc-python-command "python")
      (setq elpy-rpc-timeout 10)
      (setq python-shell-prompt-detect-failure-warning nil)
      (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
      (add-hook 'elpy-mode-hook (lambda () (elpy-shell-toggle-dedicated-shell 1)))
      ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package python-black
    :ensure t
    :after (python)
    :config
    (setq python-black-command "/usr/bin/black")
    (define-key python-mode-map "\C-cb" 'python-black-buffer)
    (define-key python-mode-map "\C-cb" 'python-black-region))
#+END_SRC
* erc
#+BEGIN_SRC emacs-lisp
      (use-package erc
        :ensure t
        :config
        (setq erc-hide-list '("PART" "QUIT" "JOIN")
              erc-server "irc.freenode.net"
              erc-nick "hooxen"
              erc-server-reconnect-timeout 30
              erc-mode-line-format "%t")
        (add-hook 'erc-text-matched-hook '(lambda (match-type nickuserhost msg)
                                            (shell-command-to-string (format "notify-send erc '%s'" msg))))
        (use-package erc-colorize
          :ensure t
          :config
          (erc-colorize-mode 1)))
#+END_SRC
* elfeed
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :disabled
    :ensure   t
    :commands elfeed
    :config
    (setq-default elfeed-search-filter "@1-week-ago ")
    (setq elfeed-feeds
          '(("https://www.archlinux.org/feeds/news/" arch)
            ("http://www.reddit.com/r/emacs/.rss" emacs reddit)
            ("http://sachachua.com/blog/category/emacs-news/feed" emacs sacha)
            ("http://endlessparentheses.com/atom.xml" emacs)
            ("http://www.masteringemacs.org/feed/" emacs)
            ("http://emacs-fu.blogspot.com/feeds/posts/default" emacs)
            ("http://emacsredux.com/atom.xml" emacs)
            ("http://arxiv.org/rss/q-fin.TR" arxiv trading)
            ("http://feeds.feedburner.com/zerohedge/feed"))
            )
    )
#+END_SRC
* mu4e
The smtp portion will require app specific password and will store it in ~/.authinfo after first use
#+BEGIN_SRC emacs-lisp
  (use-package mu4e
    :load-path "/usr/share/emacs/site-lisp/mu4e"
    :config
    (setq mu4e-maildir (expand-file-name "~/mbsync"))
    (setq mu4e-sent-folder "/sent")
    (setq mu4e-drafts-folder "/drafts")
    (setq mu4e-trash-folder "/trash")

    ;;GMail/IMAP takes care of this
    (setq mu4e-sent-messages-behavior 'delete)
    (setq mu4e-get-mail-command "mbsync -q gmail")
    (setq mu4e-update-interval 3600)
    (setq mu4e-maildir-shortcuts
    '(("/INBOX" . ?i)
      ("/sent" . ?s)))
    (setq mu4e-view-show-images t)
    (setq mu4e-use-fancy-chars t)
    (setq mu4e-view-show-addresses t)
    (setq mu4e-headers-show-threads nil)
    )
  (require 'smtpmail)
  (setq message-send-mail-function 'smtpmail-send-it
        user-mail-address "email_username@gmail.com"
        smtpmail-smtp-user "email_username"
        smtpmail-local-domain "gmail.com"
        smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587)

#+END_SRC
* deadgrep
uses rg for fast grep
#+BEGIN_SRC emacs-lisp
  (use-package deadgrep
    :ensure t
    :bind ("M-s g" . deadgrep))
#+END_SRC
* rmsbolt
#+BEGIN_SRC emacs-lisp
  (use-package rmsbolt
    :disabled
    :ensure t)
#+END_SRC
* elisp
use =paredit= in lisp modes
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :ensure t
    :config
    (add-hook 'emacs-lisp-mode-hook #'paredit-mode)
    (add-hook 'lisp-interaction-mode-hook #'paredit-mode)
    (add-hook 'ielm-mode-hook #'paredit-mode)
    (add-hook 'lisp-mode-hook #'paredit-mode)
    (add-hook 'eval-expression-minibuffer-setup-hook #'paredit-mode))
#+END_SRC
also enable eldoc
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :diminish
    :hook ((emacs-lisp-mode) . eldoc-mode))
#+END_SRC
* telega
Telegram support from emacs (needs visual-fill-column)
#+BEGIN_SRC emacs-lisp
  (use-package visual-fill-column :ensure t)
#+END_SRC
#+BEGIN_SRC emacs-lisp
      (require 'notifications)
      (use-package telega
        :disabled
        :load-path "~/3rdParty/telega/"
        :commands (telega)
        :config
        (setq telega-use-notifications t)
        (add-hook 'telega-chat-mode-hook (lambda ()
                                           (setq company-backends '(telega-company-emoji))
                                           (company-mode 1)))
        :defer t)
#+END_SRC
* leetcode
on MELPA from here [[https://github.com/kaiwk/leetcode][leetcode]]
#+BEGIN_SRC emacs-lisp
;  (use-package leetcode
;    :disabled
;    :ensure t
;    :config
;    (setq leetcode-prefer-language "cpp")
;    (setq leetcode-prefer-sql "mysql"))
#+END_SRC
* projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :init
    (setq projectile-search-path '((expand-file-name "~/development")))
    ;(setq projectile-project-root-files '("WORKSPACE"))
    (setq projectile-project-root-files-bottom-up '(".git" ".projectile"))
    :config
    (projectile-mode t)  
    ;(projectile-register-project-type 'bazel '("WORKSPACE") :compile "bazel build ...")
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    (define-key projectile-mode-map (kbd "C-c p t") 'projectile-run-term)
    (use-package helm-projectile
      :ensure t
      :init
      (helm-projectile-on)
      (setq projectile-completion-system 'helm)))
#+END_SRC
* discover
discover major mode
#+BEGIN_SRC emacs-lisp
  (use-package discover-my-major
    :ensure t
    :config
    (global-set-key (kbd "C-h C-m") 'discover-my-major))
#+END_SRC
* vlf
use for opening files larger than =large-file-warning-threshold=
#+BEGIN_SRC emacs-lisp
  (use-package vlf
    :ensure t
    :config
    (require 'vlf-setup))
#+END_SRC
* speed typing
#+BEGIN_SRC emacs-lisp
  (use-package speed-type
    :ensure t
    :disabled
    :commands (speed-type-text))
#+END_SRC
