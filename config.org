* settings
** startup
*** gc
As early as possible do this
#+BEGIN_SRC emacs-lisp
  (use-package gcmh
    :ensure t
    :diminish t
    :init
    (require 'gcmh)
    (gcmh-mode 1)
    :config
    (setq gcmh-verbose t)
    (setq gcmh-high-cons-threshold (* 100 1024 1024)))
#+END_SRC
*** native compilation
#+begin_src emacs-lisp
  (when (and (fboundp 'native-comp-available-p)
         (native-comp-available-p))
    (setq package-native-compile t))
#+end_src
*** theme
#+BEGIN_SRC emacs-lisp
(use-package doom-themes :ensure t :defer t)
(load-theme 'doom-one t)
(set-frame-font "Monospace-13")
(global-font-lock-mode t)
(setq font-lock-maximum-decoration t)
#+END_SRC
*** start
Disable a bunch of visuals
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (blink-cursor-mode -1)
  (tooltip-mode -1)
  (transient-mark-mode 1)
#+END_SRC

Disable audible bell
#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

Disable startup messages and text in scratch
#+BEGIN_SRC emacs-lisp
  (setq initial-major-mode 'fundamental-mode
        inhibit-startup-message t
        inhibit-startup-echo-area-message t
        initial-scratch-message nil)
#+END_SRC

Disable suspend
#+begin_src emacs-lisp
  (use-package frame :bind ("C-z" . nil))
#+end_src

Mute some warnings out of our control
#+begin_src emacs-lisp
  (setq ad-redefinition-action 'accept)
#+end_src
*** warnings
Disable common warnings
#+BEGIN_SRC emacs-lisp
(put 'set-goal-column 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'erase-buffer 'disabled nil)
(put 'downcase-region 'disabled nil)
(setq large-file-warning-threshold (* 120 1024 1024))
#+END_SRC
*** basic settings
#+BEGIN_SRC emacs-lisp
  (setq scroll-step 1
        scroll-margin 3
        scroll-conservatively most-positive-fixnum
        scroll-preserve-screen-position t
        grep-highlight-matches t
        shell-file-name "bash"
        x-alt-keysym 'meta
        kill-ring-max 100
        undo-outer-limit 50000000
        make-backup-files nil
        calendar-mode-line-format nil
        set-mark-command-repeat-pop t
        load-prefer-newer t
        view-read-only t
        display-raw-bytes-as-hex t)

  (use-package paren
    :custom
    (show-paren-delay 0)
    (show-paren-when-point-inside-paren t)
    :config
    (show-paren-mode 1))

  (setq enable-recursive-minibuffers t)
  (minibuffer-depth-indicate-mode)

  ;;; too slow on old server
  (unless (string= (system-name) "avalenovo")
    (setq completion-styles '(flex)))
#+END_SRC
*** save place
#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :config (save-place-mode))
#+END_SRC
*** save history and desktop
Save some history across sessions. (savehist-mode) on auto-save can be slow so we rely on desktop-save instead
#+BEGIN_SRC emacs-lisp
  (setq history-length 8000)
  (setq history-delete-duplicates t)
  (desktop-save-mode -1)

  (setq desktop-globals-to-save
        (append
         '(desktop-missing-file-waning
           (shell-command-history 8000)
           tags-file-name
           tags-table-list
           (search-ring . 8000)
           (regexp-search-ring . 8000)
           (register-alist . 800)
           (kill-ring . 8000)
           (minibuffer-history . 8000)
           (file-name-history . 8000)
           (grep-history . 8000)
           (extended-command-history . 8000)
           (compile-history . 8000)
           (read-expression-history . 8000)
           query-replace-history
           regexp-history)))
#+END_SRC
*** mode bar
show battery, column number and nicely formatted time
#+BEGIN_SRC emacs-lisp
  (setq column-number-mode t
        display-time-format "%H:%M - %Y%m%d"
        display-time-24hr-format t
        display-time-default-load-average nil)

  (display-battery-mode t)
  (display-time-mode 1)
  (size-indication-mode t)
#+END_SRC
*** highlighting
#+BEGIN_SRC emacs-lisp
(global-hi-lock-mode 1)
(setq hi-lock-auto-select-face t)
#+END_SRC
*** emacs server
#+BEGIN_SRC emacs-lisp
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+END_SRC
*** buffers
kill current buffer no prompt
#+BEGIN_SRC emacs-lisp
(defun kill-current-buffer ()
  "Kill the current buffer, without confirmation."
  (interactive)
  (kill-buffer (current-buffer)))
(global-set-key "\C-xk" 'kill-current-buffer)
#+END_SRC

#+begin_src emacs-lisp
  (setq display-buffer-base-action
        '(display-buffer-reuse-mode-window
          display-buffer-reuse-window
          display-buffer-same-window))

  (setq even-window-sizes nil)

  (add-to-list 'same-window-buffer-names "*grep*")
  (add-to-list 'same-window-buffer-names "*Buffer List*")
#+end_src
*** misc
#+BEGIN_SRC emacs-lisp
  (setq world-clock-time-format "%a, %d %b %I:%M %p %Z"
        world-clock-list '(("Europe/Berlin" "Berlin")
                           ("America/Chicago" "Chicago")
                           ("Asia/Hong_Kong" "Hong Kong")
                           ("Europe/London" "London")
                           ("America/Mexico_City" "Mexico City")
                           ("Asia/Shanghai" "Shanghai")
                           ("Asia/Singapore" "Singapore")
                           ("Asia/Tokyo" "Tokyo")
                           ("Etc/UTC" "UTC")
                           ("Europe/Zurich" "Zurich")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package winner
    :bind (("M-N" . winner-redo)
           ("M-P" . winner-undo))
    :config
    (when (boundp 'winner-boring-buffers-regexp)
      (setq winner-boring-buffers-regexp "\\*[hH]elm.*"))
    (winner-mode 1))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
  (global-set-key (kbd "C-x l") 'align-regexp)
  (global-set-key [remap eval-last-sexp] 'pp-eval-last-sexp)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (global-set-key "\M-z" 'zap-up-to-char)
  (global-set-key "\M-Z" (lambda (char)
                           (interactive "cZap back to char: ")
                           (zap-up-to-char -1 char)))
#+END_SRC

#+begin_src emacs-lisp
  (global-unset-key (kbd "C-x o"))
#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package isearch
    :no-require t
    :defer t
    :config
    (when (version<= "27" emacs-version)
      (setq isearch-lazy-count t
            isearch-allow-scroll 'unlimited))
    (define-key isearch-mode-map [remap isearch-delete-char] #'isearch-del-char))
#+END_SRC

#+begin_src emacs-lisp
  (add-hook 'after-save-hook #'executable-make-buffer-file-executable-if-script-p)
#+end_src

auto-update proced every second
#+begin_src emacs-lisp
  (use-package proced
    :defer t
    :config
    (progn
      (setq proced-auto-update-interval 1)
      (add-hook 'proced-mode-hook (lambda () (proced-toggle-auto-update +1)))))
#+end_src

instead of dabbrev, use hippie-expand with dabbrev as first method
#+begin_src emacs-lisp
  (use-package hippie-exp
    :custom
    (hippie-expand-try-functions-list
     '(try-expand-dabbrev
       try-expand-dabbrev-all-buffers
       try-expand-dabbrev-from-kill
       try-complete-file-name-partially
       try-complete-file-name
       try-expand-all-abbrevs
       try-expand-list
       try-expand-line
       try-complete-lisp-symbol-partially
       try-complete-lisp-symbol))
    :bind
    ([remap dabbrev-expand] . hippie-expand))
#+end_src
*** windows
if need to work in a windows environment talk to it via named pipe
#+begin_src emacs-lisp
;;  (defun ava/on-windows (cmd &rest args)
;;    (apply 'start-process "ON-WINDOWS" nil "~/scripts/linux_to_windows.sh"))
;;
;;  (defun ava/on-windows-open-url (url &rest args)
;;    (interactive "P")
;;    (ava/on-windows "start" (or url (url-get-url-at-point))))
;;  (setq browse-url-browser-function 'ava/on-windows-open-url)
;;
;;  (defun ava/on-windows-serve-dir ()
;;    (interactive)
;;    (let ((dir-to-serve nil))
;;      (if (equal major-mode 'dired-mode)
;;          (progn
;;            (setq dir-to-serve (dired-get-filename))
;;            (when (not (file-directory-p dir-to-serve))
;;              (setq dir-to-serve (file-name-directory dir-to-serve))))
;;        (setq dir-to-serve (buffer-file-name))
;;        (when dir-to-serve
;;          (setq dir-to-serve (file-name-directory dir-to-serve))))
;;      (cl-assert dir-to-serve t "could not determine directory to serve")
;;      (save-excursion
;;        (set-buffer (generate-new-buffer (format "httpserve %s" dir-to-serve)))
;;        (async-shell-command (format "~/scripts/serve_dir_open_on_windows.sh %s" dir-to-serve) (current-buffer)))))
#+end_src
** development
*** general
#+BEGIN_SRC emacs-lisp
  (setq text-scale-mode-step 1.1
        help-enable-symbol-autoload t)
  (setq-default tab-width 4
                fill-column 80
                indent-tabs-mode nil)
#+END_SRC
*** tags and locate
based on https://emacs.stackexchange.com/questions/41256/using-advice-to-run-function-before-tag-symbol-lookup/41277
check if projectile root has a TAGS file and if not generate something

#+BEGIN_SRC emacs-lisp
  (defun ava/generate-tags ()
    "Generate project TAGS"
    (interactive)
    (cl-assert (projectile-project-root) nil "not in a project")
    (let* ((prjd (projectile-project-root))
           (tagd (concat prjd ".tagsAndLocate"))
           (tagf (concat tagd "/TAGS")))
      (make-directory tagd t)
      (shell-command
       (format "ctags -f %s -e --verbose --totals=yes --links=no \
                --kinds-c++=+p --languages=c,c++,lisp --langmap=c++:+.I \
                -R %s &> %s/ctags.out" tagf prjd tagd))
      (message "generated %s (%s)" tagf
               (shell-command-to-string (format "du -sh %s | cut -f1 | tr -d '\n'" tagf)))))

  ;; TODO only needed if have to locate outside project and no lsp use
  (defun ava/generate-locates ()
    "Generate project locate.db for helm"
    (interactive)
    (cl-assert (projectile-project-root) nil "not in a project"))

  (defun ava/generate-tags-and-locates ()
    "Called interactivel to generate both locate.db and tags for project"
    (interactive)
    (ava/generate-tags)
    (ava/generate-locates))

  (defun ava/before-xref-find-defs (&rest _)
    (when (projectile-project-root)
      (let ((project-tags-file (concat (projectile-project-root) ".tagsAndLocate/TAGS")))
        (if (file-exists-p project-tags-file)
            (visit-tags-table project-tags-file t)
          (ava/generate-tags)))))

  (advice-add 'xref-find-definitions :before #'ava/before-xref-find-defs)
#+END_SRC
*** semantic mode
use semantic without it interfering with completion and without auto-parsing in idle time
(only use it for helm-semantic-or-imenu and thus parses buffer on demand)
#+BEGIN_SRC emacs-lisp
  (require 'semantic)
  (add-hook 'semantic-mode-hook
            (lambda ()
              (dolist (x (default-value 'completion-at-point-functions))
                (when (string-prefix-p "semantic-" (symbol-name x))
                  (remove-hook 'completion-at-point-functions x)))))
  (setq semantic-default-submodes '(global-semanticdb-minor-mode))
  (semantic-mode 1)
#+END_SRC
*** c/c++
indentation related
#+BEGIN_SRC emacs-lisp
(setq c-default-style "linux"
      c-basic-offset 4)
(c-set-offset 'innamespace 0)
#+END_SRC
toggle between implementation and header
#+BEGIN_SRC emacs-lisp
  (setq cc-search-directories '("."))
  (setq cc-other-file-alist
        '(("\\.cpp$" (".h" ".hpp"))
          ("\\.h$" (".cpp" ".c"))
          ("\\.hpp$" (".cpp" ".c"))
          ("\\.C$" (".H"))
          ("\\.H$" (".C"))))

  (add-hook 'c-mode-common-hook (lambda() (global-set-key (kbd "C-c o") 'ff-find-other-file)))
#+END_SRC

*** compilation
#+BEGIN_SRC emacs-lisp
  (use-package compile
    :custom
    (compile-command "make")
    (compilation-always-kill t)
    (compilation-scroll-output 'first-error)
    (compilation-read-command nil)
    (compilation-ask-about-save nil)
    (compilation-skip-threshold 2)
    (next-error-message-highlight t)
    :hook (compilation-filter . ava/colorize-compilation-buffer)
    :config
    (progn
      ;; http://stackoverflow.com/questions/13397737
      (defun ava/colorize-compilation-buffer ()
        (require 'ansi-color)
        (let ((inhibit-read-only t))
          (ansi-color-apply-on-region compilation-filter-start (point))))))
#+END_SRC
*** ediff
#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :custom
    (ediff-highlight-all-diffs nil)
    (ediff-window-setup-function #'ediff-setup-windows-plain)
    (ediff-split-window-function #'split-window-horizontally)
    (ediff-grab-mouse nil)
    (ediff-keep-variants nil)
    (ediff-diff-options "-w")
    :bind (("C-c = b" . ediff-buffers)
           ("C-c = B" . ediff-buffers3)
           ("C-c = c" . compare-windows)
           ("C-c = f" . ediff-files)
           ("C-c = F" . ediff-files3)
           ("C-c = m" . count-matches)
           ("C-c = r" . ediff-revision)
           ("C-c = p" . ediff-patch-file)
           ("C-c = P" . ediff-patch-buffer)
           ("C-c = l" . ediff-regions-linewise)
           ("C-c = w" . ediff-regions-wordwise))
    :config
    (add-hook 'ediff-prepare-buffer-hook #'outline-show-all))
#+END_SRC
*** re-builder
bridge re-builder with query regexp replace
(from https://karthinks.com/software/bridging-islands-in-emacs-1/)
#+begin_src emacs-lisp
  (use-package re-builder
    :config
    (setq reb-re-syntax 'string)
    (defvar ava/re-builder-positions nil
      "Store point and region bounds before calling re-builder")
    (advice-add 're-builder
                :before
                (defun ava/re-builder-save-state (&rest _)
                  "Save into `ava/re-builder-positions' the point and region
                 positions before calling `re-builder'."
                  (setq ava/re-builder-positions
                        (cons (point)
                              (when (region-active-p)
                                (list (region-beginning)
                                      (region-end)))))))
    (defun ava/reb-replace-regexp (&optional delimited)
      "Run `query-replace-regexp' with the contents of re-builder. With
  non-nil optional argument DELIMITED, only replace matches
  surrounded by word boundaries."
      (interactive "P")
      (reb-update-regexp)
      (let* ((re (reb-target-binding reb-regexp))
             (replacement (query-replace-read-to
                           re
                           (concat "Query replace"
                                   (if current-prefix-arg
                                       (if (eq current-prefix-arg '-) " backward" " word")
                                     "")
                                   " regexp"
                                   (if (with-selected-window reb-target-window
                                         (region-active-p)) " in region" ""))
                           t))
             (pnt (car ava/re-builder-positions))
             (beg (cadr ava/re-builder-positions))
             (end (caddr ava/re-builder-positions)))
        (with-selected-window reb-target-window
          (goto-char pnt) ; replace with (goto-char (match-beginning 0)) if you want
                                          ; to control where in the buffer the replacement starts
                                          ; with re-builder
          (setq ava/re-builder-positions nil)
          (reb-quit)
          (query-replace-regexp re replacement delimited beg end))))

    (define-key reb-mode-map (kbd "RET") #'ava/reb-replace-regexp)
    (define-key reb-lisp-mode-map (kbd "RET") #'ava/reb-replace-regexp)
    (global-set-key (kbd "C-M-%") #'re-builder))
#+end_src
* active packages
** ace
#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :bind (("M-o" . ace-window))
    :custom
    (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
    (aw-background nil))
    ;:config (set-face-attribute
    ;         'aw-leading-char-face nil :height 3.0))
#+end_src

#+begin_src emacs-lisp
  (use-package ace-link
    :ensure t
    :config (ace-link-setup-default)
    (add-hook 'ess-r-help-mode-hook #'(lambda () (bind-key "o" #'ace-link-help ess-r-help-mode-map))))
#+end_src
** auctex
#+BEGIN_SRC emacs-lisp
    (use-package tex
      :ensure auctex
      :defer t
      :custom
      (TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
      :hook
      (LaTeX-mode . (lambda ()
                      (turn-on-reftex)
                      (setq reftex-plug-into-AUCTeX t)
                      (reftex-isearch-minor-mode)
                      (setq TeX-source-correlate-start-server t))))

    (use-package company-auctex
      :after tex
      :ensure t
      :commands (company-auctex
                 company-auctext-labels
                 company-auctest-bibs
                 company-auctex-macros
                 company-auctext-symbols
                 company-auctext-environments)
      :hook
      (tex-mode . (lambda ()
                    (setq-local company-backends '((company-auctex-labels
                                                    company-auctex-bibs
                                                    company-auctex-macros
                                                    company-auctex-environments
                                                    company-auctex-symbols
                                                    company-capf))))))
#+END_SRC
** auto package updating
stay up to date
#+BEGIN_SRC emacs-lisp
  (use-package auto-package-update
    :ensure t
    :if (not (daemonp))
    :custom
    (auto-package-update-interval 90)
    (auto-package-update-prompt-before-update t)
    (auto-package-update-delete-old-versions t)
    (auto-package-update-hide-results t)
    :config
    (auto-package-update-maybe))
#+END_SRC
** avy
from [[https://gist.github.com/karthink/af013ffd77fe09e67360f040b57b4c7b][karthink]]
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind (("M-j" . avy-goto-char-timer)
           ("M-g M-g" . avy-goto-line)
           )
    :custom
    (avy-timeout-seconds 0.3)
    (avy-keys '(?q ?e ?r ?u ?o ?p ?a ?s ?d ?f ?g ?h ?j ?k ?l ?x ?c ?v ?b ?n ?,))
    :init
    (bind-key "M-j" 'avy-isearch isearch-mode-map)
    :config
    (when (display-graphic-p)
      (setq avy-background t))
    (progn ;kill text
      (defun avy-action-kill-whole-line (pt)
        (save-excursion
          (goto-char pt)
          (kill-whole-line))
        (select-window (cdr (ring-ref avy-ring 0))) t)
      (setf (alist-get ?k avy-dispatch-alist) 'avy-action-kill-stay
            (alist-get ?K avy-dispatch-alist) 'avy-action-kill-whole-line))
    (progn ;copy text
      (defun avy-action-copy-whole-line (pt)
        (save-excursion
          (goto-char pt)
          (cl-destructuring-bind (start . end)
              (bounds-of-thing-at-point 'line)
            (copy-region-as-kill start end)))
        (select-window (cdr (ring-ref avy-ring 0))) t)
      (setf (alist-get ?w avy-dispatch-alist) 'avy-action-copy
            (alist-get ?W avy-dispatch-alist) 'avy-action-copy-whole-line))
    (progn ;yank text
      (defun avy-action-yank-whole-line (pt)
        (avy-action-copy-whole-line pt)
        (save-excursion (yank)) t)
      (setf (alist-get ?y avy-dispatch-alist) 'avy-action-yank
            (alist-get ?Y avy-dispatch-alist) 'avy-action-yank-whole-line))
    (progn ;transpose text
      (defun avy-action-teleport-whole-line (pt)
        (avy-action-kill-whole-line pt)
        (save-excursion (yank)) t)
      (setf (alist-get ?t avy-dispatch-alist) 'avy-action-teleport
            (alist-get ?T avy-dispatch-alist) 'avy-action-teleport-whole-line))
    (progn ;helpful
      (defun avy-action-helpful (pt)
        (save-excursion
          (goto-char pt)
          (helpful-at-point))
        (select-window (cdr (ring-ref avy-ring 0))) t)
      (setf (alist-get ?H avy-dispatch-alist) 'avy-action-helpful))
    (progn ;dash
      (defun avy-action-dash (pt)
        (save-excursion
          (goto-char pt)
          (helm-dash-at-point))
        (select-window (cdr (ring-ref avy-ring 0))) t)
      (setf (alist-get ?D avy-dispatch-alist) 'avy-action-dash))
    (progn ;man
      (defun avy-action-man (pt)
        (save-excursion
          (goto-char pt)
          (helm-man-woman nil))
        (select-window (cdr (ring-ref avy-ring 0))) t)
      (setf (alist-get ?M avy-dispatch-alist) 'avy-action-man)))
#+END_SRC
** bookmarks
modified from https://github.com/howardabrams/dot-files/blob/master/emacs.org
#+begin_src emacs-lisp
  (use-package bookmark
    :init (setq bookmark-save-flag 1)
    :config
    (defun ava/add-bookmark (name)
      (interactive
       (list
        (let* ((initial
                (cond
                 ((and (fboundp 'which-function) (not (string= (projectile-project-name) "-")))
                  (format "%s::%s:%s - " (projectile-project-name) (file-name-base (buffer-file-name)) (which-function)))
                 ((buffer-file-name)
                  (format "%s - " (buffer-file-name)))
                 (t "? - "))))
          (read-string "Bookmark: " initial))))
      (bookmark-set name))
    :bind (("C-x r m" . ava/add-bookmark)))
#+end_src
** clang-format
#+BEGIN_SRC emacs-lisp
  (use-package clang-format
    :ensure t
    :commands clang-format-buffer clang-format-region)

  (use-package cc-mode
    :defer t
    :config
    (bind-key "C-c b" #'clang-format-buffer c-mode-base-map))
#+END_SRC
** company
*** company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :custom
    (company-dabbrev-downcase nil)
    (company-idle-delay 0.1)
    (company-minimum-prefix-length 1)
    (company-require-match nil)
    (company-show-numbers t)
    (company-tooltip-limit 20)
    (company-tooltip-align-annotations t)
    (company-selection-wrap-around t)
    (company-global-modes '(not compilation-mode magit-status-mode reb-mode))
    (company-backends '(company-clang company-capf company-files
                                      (company-dabbrev-code company-gtags company-etags company-keywords)
                                      company-dabbrev))
    :config
    (define-key company-mode-map (kbd "C-:") 'company-complete-common)
    (define-key company-active-map (kbd "<tab>") 'smarter-yas-expand-next-field-complete)
    (global-company-mode 1)
    (defun smarter-yas-expand-next-field-complete ()
      "Try to `yas-expand' and `yas-next-field' at current cursor position.

  If failed try to complete the common part with `company-complete-common'"
      (interactive)
      (if yas-minor-mode
          (let ((old-point (point))
                (old-tick (buffer-chars-modified-tick)))
            (yas-expand)
            (when (and (eq old-point (point))
                       (eq old-tick (buffer-chars-modified-tick)))
              (ignore-errors (yas-next-field))
              (when (and (eq old-point (point))
                         (eq old-tick (buffer-chars-modified-tick)))
                (company-complete-common))))
        (company-complete-common))))
#+END_SRC
*** posframe
A much nicer frame for completion candidates
#+BEGIN_SRC emacs-lisp
  (use-package company-posframe
    :ensure t
    :config
    (company-posframe-mode 1))
#+END_SRC
*** helm company
#+BEGIN_SRC emacs-lisp
    (use-package helm-company
      :ensure t
      :config
      (define-key company-mode-map (kbd "C-:") 'helm-company))
#+END_SRC
*** company-shell
backend for shells
#+BEGIN_SRC emacs-lisp
  (use-package company-shell
    :ensure t
    :after company
    :config
    (add-to-list 'company-shell-modes 'term-mode)
    (add-hook
     'term-mode-hook (lambda ()
                       (set (make-local-variable 'company-idle-delay) 0.5)
                       (set (make-local-variable 'company-minimum-prefix-length) 2)
                       (set (make-local-variable 'company-backends)
                            '((company-capf company-files company-shell company-shell-env) company-dabbrev)))))
#+END_SRC
** deadgrep
uses rg for fast grep
#+BEGIN_SRC emacs-lisp
  (use-package deadgrep
    :ensure t
    :bind (("M-s g" . deadgrep)
           (:map deadgrep-mode-map ("C-c C-w" . #'deadgrep-edit-mode))))
#+END_SRC
** dired related
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'dired
    (require 'dired-x)
    (setq
     dired-recursive-copies 'always
     dired-recursive-deletes 'always
     dired-dwim-target t
     dired-auto-revert-buffer 'dired-directory-changed-p
     dired-listing-switches "-Al --si --time-style long-iso --group-directories-first"
     dired-hide-details-hide-symlink-targets nil
     dired-kill-when-opening-new-dired-buffer t)
    (add-hook 'dired-mode-hook (lambda () (interactive) (dired-hide-details-mode 1))))
#+END_SRC
a much nicer dired (can in-place expand subdirectory contents)
#+BEGIN_SRC emacs-lisp
  (use-package dired-subtree
    :ensure t
    :after dired
    :bind (:map dired-mode-map
                ("i" . dired-subtree-insert)
                (";" . dired-subtree-remove)
                ("<tab>" . dired-subtree-cycle)))
#+END_SRC

replaces list-directory with recentf for dirs
#+begin_src emacs-lisp
  (use-package dired-recent
    :ensure t
    :config (dired-recent-mode 1))
#+end_src
** discover
discover major mode
#+BEGIN_SRC emacs-lisp
  (use-package discover-my-major
    :ensure t
    :bind (("C-h C-m" . discover-my-major)
           ("C-h C-d" . discover-my-mode)))
#+END_SRC
** dumb jump
#+begin_src emacs-lisp
  (use-package dumb-jump
    :ensure t
    :custom
    (dumb-jump-selector 'helm)
    (dumb-jump-confirm-jump-to-modified-file nil)
    :bind
    (:map prog-mode-map
          (("C-c C-j" . dumb-jump-go))))
#+end_src
** easy kill
Use ~M-w~ and modifiers to more efficiently save things to kill ring
#+BEGIN_SRC emacs-lisp
  (use-package easy-kill
  :ensure t
  :config
  (global-set-key [remap kill-ring-save] #'easy-kill)
  (global-set-key [remap mark-sexp] #'easy-mark))
#+END_SRC
** elisp
use =paredit= in lisp modes ([[http://danmidwood.com/content/2014/11/21/animated-paredit.html][animated paredit guide]])
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :ensure t
    ;:bind (:map paredit-mode-map ("M-I" . paredit-splice-sexp)) ;fixme (breaks paredit hooks below)
    :config
    (add-hook 'paredit-mode-hook #'(lambda () (unbind-key "M-s" paredit-mode-map)))
    (add-hook 'emacs-lisp-mode-hook #'paredit-mode)
    (add-hook 'lisp-interaction-mode-hook #'paredit-mode)
    (add-hook 'ielm-mode-hook #'paredit-mode)
    (add-hook 'lisp-mode-hook #'paredit-mode)
    (add-hook 'eval-expression-minibuffer-setup-hook #'paredit-mode))
#+END_SRC
also enable eldoc
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :diminish
    :hook ((emacs-lisp-mode) . eldoc-mode))
#+END_SRC
** erc
use =M-x erc-tls= to start
#+begin_src emacs-lisp
  (use-package erc
    :ensure t
    :init
    (require 'erc-autoaway)
    :custom
    (erc-lurker-hide-list '("PART" "QUIT" "JOIN"))
    (erc-server "irc.libera.chat")
    (erc-nick "hooxen")
    (erc-join-buffer 'buffer)
    (erc-interpret-mirc-color t)
    (erc-server-reconnect-timeout 10)
    (erc-autoaway-idle-seconds 600)
    :config
    (add-hook 'erc-text-matched-hook #'(lambda (match-type nickuserhost msg)
                                         (shell-command-to-string (format "notify-send erc '%s'" msg))))
    (use-package erc-colorize
      :ensure t
      :config (erc-colorize-mode 1)))
#+end_src
** ess
#+BEGIN_SRC emacs-lisp
  (use-package ess
    :ensure t
    :init
    (require 'ess-site)
    :config
    (setq inferior-R-program-name "/usr/bin/R"
          inferior-R-args "--no-save --no-restore-data --quiet"
          ess-eval-visibly-p nil
          ess-directory "~/"
          ess-use-flymake nil
          ess-indent-with-fancy-comments nil
          ess-ask-for-ess-directory nil)
    ;http://stackoverflow.com/questions/780796/emacs-ess-mode-tabbing-for-comment-region
    (defun ava-ess-settings ()
      (setq ess-indent-with-fancy-comments nil))
    (add-hook 'ess-mode-hook #'ava-ess-settings)
    (define-key ess-r-mode-map "_" #'ess-insert-assign)
    (define-key inferior-ess-r-mode-map "_" #'ess-insert-assign))
#+END_SRC
** expand region
#+begin_src emacs-lisp
  (use-package expand-region
    :ensure t
    :bind
    (("C-=" . er/expand-region)
     :map mode-specific-map
     :prefix-map region-prefix-map
     :prefix "r"
     ("(" . er/mark-inside-pairs)
     (")" . er/mark-outside-pairs)
     ("'" . er/mark-inside-quotes)
     ([34] . er/mark-outside-quotes) ; "
     ("o" . er/mark-org-parent)
     ("u" . er/mark-url)
     ("b" . er/mark-org-code-block)
     ("." . er/mark-method-call)
     ("w" . er/mark-word)
     ("d" . er/mark-defun)
     ("s" . er/mark-symbol)
     (";" . er/mark-comment)
     ("S" . er/mark-sentence)
     ("P" . er/mark-paragraph)))
#+end_src
** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck :ensure t)
#+END_SRC

add clang-tidy to flycheck

#+begin_src emacs-lisp
;  (use-package flycheck-clang-tidy
;    :ensure t
;    :after flycheck
;    :hook (flycheck-mode . flycheck-clang-tidy-setup))
#+end_src
** git-gutter
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :ensure t
    :init
    (global-git-gutter-mode +1))
#+END_SRC
** git-timemachine
#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :ensure t
    :bind ("C-x v t" . git-timemachine-toggle))
#+END_SRC
** helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :demand t
    :diminish helm-mode
    :init
    (progn
      (require 'helm-config)
      (setq helm-candidate-number-limit 100)
      (setq helm-idle-delay 0.0
            helm-input-idle-delay 0.01
            helm-yas-display-key-on-candidate t
            helm-quick-update t
            helm-M-x-requires-pattern nil)
      (helm-mode))
    :bind (
           ("C-h a" . helm-apropos)
           ("C-x b" . helm-mini)
           ("M-y" . helm-show-kill-ring)
           ("M-x" . helm-M-x)
           ("C-x C-f" . helm-find-files)
           ("C-c h o" . helm-occur)
           ("C-c h b" . helm-resume)
           ("C-c h i" . helm-semantic-or-imenu)
           ("C-c h m" . helm-man-woman)
           ("C-c h I" . helm-imenu-in-all-buffers)
           ("C-c h l" . helm-locate)
           ("C-c h g" . helm-google-suggest)
           ("C-c h t" . helm-top)
           ("C-c h x" . helm-shell-history)
           ("C-c h p" . org-projectile-helm-template-or-project)
           ("C-c h <SPC>" . helm-all-mark-rings))
    :config
    (setq helm-command-prefix-key "C-c h")
    (setq helm-autoresize-min-height 25)
    (setq helm-autoresize-max-height 25)
    (setq helm-split-window-in-side-p t
          helm-move-to-line-cycle-in-source t
          helm-ff-search-library-in-sexp t
          helm-scroll-amount 8
          helm-ff-file-name-history-use-recentf t)
    (setq helm-buffer-max-length nil)
    ;;locate %s -d FOO -e --regex %s where FOO is : delimited from cmd updatedb -l 0 -o i.db -U path_i for all paths
    ;;(defvar my-locate-db-command (with-temp-buffer (insert-file-contents "path/to/cmd.txt") (buffer-string)))
    ;;(setq helm-locate-command my-locae-db-command)
    (helm-mode 1)
    (helm-autoresize-mode 1)
    (define-key  helm-map (kbd "<tab>") 'helm-execute-persistent-action)
    (define-key  helm-map (kbd "C-i") 'helm-execute-persistent-action)
    (define-key  helm-map (kbd "C-z") 'helm-select-action)
    (defun ava/around-helm-buffers-sort-transformer (candidates source)
      candidates)
    (advice-add 'helm-buffers-sort-transformer
                :override #'ava/around-helm-buffers-sort-transformer)
    (defun ava/reset-helm-buffer-max-length (&rest ignore) (setq helm-buffer-max-length nil))
    (advice-add 'helm-mini :before #'ava/reset-helm-buffer-max-length)
    :ensure helm)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package helm-swoop
    :ensure t
    :bind (("C-c h s" . helm-multi-swoop))
    :custom (helm-swoop-speed-or-color t)
    :init
    (bind-key "M-i" 'helm-swoop-from-isearch isearch-mode-map)
    :config
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-current-mode-from-helm-swoop))

  (use-package helm-rg :ensure t)
  (use-package helm-ag :ensure t
    :custom
    (helm-ag-use-agignore t)
    (helm-ag-insert-at-point 'symbol))
#+END_SRC

remap =term-previous-matching-input= to a helm frontend
#+BEGIN_SRC emacs-lisp
  (use-package helm-shell-history
    :load-path "~/.emacs.d/lisp/helm-shell-history"
    :after term vterm
    :config
    (setq helm-shell-history-file "~/.bash_eternal_history")
    (setq helm-shell-history-fuzzy-match t)
    (setq helm-shell-history-fast-parser "~/development/helm-shell-history/src/parse_history")
    (define-key term-mode-map (kbd "M-r") 'helm-shell-history)
    (define-key vterm-mode-map (kbd "M-r") 'helm-shell-history))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package helm-descbinds
    :ensure t
    :init (helm-descbinds-mode))
#+END_SRC

[[https://lucasg.github.io/2017/02/05/Downloading-Dash-docsets/][dash docsets]]
#+begin_src emacs-lisp
  (use-package helm-dash
    :ensure t
    :bind (("C-c h d" . helm-dash-at-point))
    :custom
    (dash-docs-enable-debugging nil)
    (dash-docs-browser-func #'eww)
    :config
    (require 'dash-docs)
    (setq dash-docs-common-docsets '("Matplotlib" "Python 3" "NumPy" "Pandas")))
#+end_src

#+begin_src emacs-lisp
  (use-package helm-org-rifle
    :ensure t
    :bind
    ("C-c h r r" . helm-org-rifle)
    ("C-c h r a" . helm-org-rifle-org-agenda-files)
    ("C-c h r o" . helm-org-rifle-org-directory))
#+end_src
** helpful
#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :ensure t
    :bind
    (("C-h f" . helpful-callable)
     ("C-h v" . helpful-variable)
     ("C-h k" . helpful-key)
     ("C-c C-d" . helpful-at-point)
     ("C-h F" . helpful-funtion)
     ("C-h C" . helpful-command)))
#+END_SRC
** hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure hydra
    :init
    (global-set-key
     (kbd "C-c g")
     (defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1) :hint nil)
       "
     Up^^        Down^^               Miscellaneous
    ------------------------------------------------------------------
     [_p_] Prev  [_n_] Next [_<SPC>_] Show  [_r_] Revert [_q_] Quit
     [_h_] First [_l_] Last [_s_]     Stage [_d_] Digest"
       ("n" git-gutter:next-hunk)
       ("p" git-gutter:previous-hunk)
       ("h" (progn (goto-char (point-min)) (git-gutter:next-hunk 1)))
       ("l" (progn (goto-char (point-min)) (git-gutter:previous-hunk 1)))
       ("<SPC>" git-gutter:popup-hunk)
       ("s" git-gutter:stage-hunk)
       ("r" git-gutter:revert-hunk)
       ("r" git-gutter:revert-hunk)
       ("d" git-gutter:statistic)
       ("q" nil)))

    (global-set-key
     (kbd "C-c e")
     (defhydra hydra-paredit (:hint nil)
       "
     Forward^^   Backward^^  Miscellaneous
    ------------------------------------------------------------------
     [_n_] Next  [_p_]   Next  [_r_] Raise  [_q_] Quit
     [_s_] Slurp [_M-s_] Slurp [_l_] Splice
     [_b_] Barf  [_M-b_] Barf  [_u_] Undo"
       ("n" paredit-forward)
       ("s" paredit-forward-slurp-sexp)
       ("b" paredit-forward-barf-sexp)
       ("p" paredit-backward)
       ("M-s" paredit-backward-slurp-sexp)
       ("M-b" paredit-backward-barf-sexp)
       ("r" paredit-raise-sexp)
       ("l" paredit-splice-sexp)
       ("u" undo-only)
       ("q" nil)))

    (global-set-key
     (kbd "C-c w")
     (defhydra hydra-windows (:hint nil)
       ("r" rotate-frame-clockwise "clockwise")
       ("\\" rotate-frame-clockwise "anticlockwise")
       ("v" flip-frame "flip")
       ("f" flop-frame "flop")
       ("j" (shrink-window -10) "down")
       ("k" (shrink-window 10) "up")
       ("h" (shrink-window 10 t) "shrink")
       ("l" (shrink-window -10 t) "widen")
       ("0" (balance-windows) "balance")
       ("q" nil "quit"))))
#+END_SRC
** ibuffer
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind ("C-x C-b" . ibuffer)
    :config (define-key ibuffer-mode-map (kbd "M-o") nil))
#+END_SRC
** lsp
Some references here:
[[https://github.com/MaskRay/ccls/wiki/lsp-mode][ccls + lsp]]
[[https://github.com/rememberYou/.emacs.d/blob/master/config.org#lsp][example A]]
[[https://github.com/MatthewZMD/.emacs.d#org75e3a83][example B]] and [[https://github.com/MatthewZMD/.emacs.d#orga4fa68f][B2]]
[[http://ivanmalison.github.io/dotfiles/#languageserverprotocollsp][example C]]
[[https://github.com/jimeh/.emacs.d/blob/master/modules/lsp/siren-lsp.el][goodies]]
[[https://github.com/waymondo/hemacs/blob/master/init.el][lsp-ui goodies]]
[[https://github.com/novoid/dot-emacs/blob/master/config.org][lsp-ui more goodies]]
[[https://emacs-lsp.github.io/lsp-mode/tutorials/how-to-turn-off/][how-to-turn-off]]
[[http://blog.binchen.org/posts/how-to-speed-up-lsp-mode/][example D]]

Only use lsp with flycheck
(rather than hook, manual enable via ==M-x lsp==)
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :ensure t
    :after flycheck
    :commands lsp
    :bind
    (:map lsp-mode-map
          ([remap xref-find-references] . lsp-find-references)
          ([remap xref-find-definitions] . lsp-find-definition))
    :custom
    (lsp-keymap-prefix "C-c u")
    (lsp-auto-configure t)
    (lsp-eldoc-hook nil)
    (lsp-eldoc-enable-hover t)
    (lsp-diagnostics-provider :none)
    (lsp-enable-symbol-highlighting nil)
    (lsp-headerline-breadcrumb-enable nil)
    (lsp-lens-enable t)
    (lsp-modeline-code-actions-enable t)
    (lsp-modeline-diagnostics-enable nil)
    (lsp-signature-render-documentation t)
    (lsp-completion-show-kind t)
    (lsp-completion-show-detail t)
    (lsp-enable-file-watchers t)
    (lsp-file-watch-threshold nil)
    (lsp-enable-xref t)
    (lsp-enable-imenu t)
    (lsp-enable-folding nil)
    (lsp-enable-links nil)
    (read-process-output-max (* 1024 1024))
    ;:config
    ;(define-key  lsp-mode-map (kbd "C-c u") 'lsp-describe-thing-at-point)
    )
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (use-package lsp-ui
      :ensure t
      :after lsp-mode flycheck
      :diminish
      :commands lsp-ui-mode
      :bind
      (:map lsp-ui-mode-map
            ;("C-c u" . lsp-ui-imenu)
            ;("C-c C-d" . lsp-ui-doc-glance)
            ("C-c d" . lsp-ui-doc-show)
            ("M-i" . lsp-ui-doc-focus-frame))
      :custom
      (lsp-ui-peek-enable t)
      (lsp-ui-doc-enable t)
      (lsp-ui-doc-alignment 'window)
      (lsp-ui-doc-header t)
      (lsp-ui-doc-max-height 45)
      (lsp-ui-doc-position 'at-point)
      (lsp-ui-doc-show-with-mouse nil)
      (lsp-ui-doc-show-with-cursor nil)
      (lsp-ui-doc-include-signature t)
      (lsp-ui-doc-border (face-foreground 'default))
      (lsp-ui-sideline-enable t)
      (lsp-ui-sideline-ignore-duplicate t)
      (lsp-ui-sideline-show-code-actions nil)
      (lsp-ui-sideline-show-diagnostics nil)
      (lsp-ui-sideline-show-hover nil))

  ;(use-package company-lsp
  ;    :ensure t
  ;    :custom (company-lsp-cache-candidates 'auto))
#+END_SRC
** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :preface
    (defun ava/format-staged ()
      (interactive)
      (dolist (name (magit-staged-files))
        (let ((fname (expand-file-name name (magit-toplevel))))
          (when (file-exists-p fname)
            (pcase (file-name-extension name)
              ("py"
               (shell-command (format "dos2unix -q %s" fname)))
              ((or "C" "H" "I" "c" "h" "cpp" "hpp")
               (shell-command (format "dos2unix -q %s && clang-format --style=file -i %s" fname fname))))))))
    :custom
    (magit-display-buffer-function #'magit-display-buffer-fullcolumn-most-v1)
    (magit-log-section-commit-count 25)
    (magit-diff-refine-hunk 'all)
    (magit-no-confirm '(stage-all-changes unstage-all-changes set-and-push))
    :bind
    ("C-x g" . magit-status)
    ("C-c m" . magit-file-dispatch))
#+END_SRC

#+begin_src emacs-lisp
  (use-package forge
    :ensure t
    :after magit
    :config
    (remove-hook 'magit-status-sections-hook 'forge-insert-issues))
#+end_src
** mixed-pitch
addresses the issues with =variable-pitch-mode= in modes like org (tables/code-blocks)
#+begin_src emacs-lisp
  (use-package mixed-pitch
    :ensure t
    :defer t
    :config
    (dolist (face '(org-date org-priority org-tag org-special-keyword))
      (add-to-list 'mixed-pitch-fixed-pitch-faces face)))
#+end_src
** move-text
meta up and down to move text or region
#+begin_src emacs-lisp
  (use-package move-text :ensure t :config (move-text-default-bindings))
#+end_src
** multiple cursors
- power hydra [[https://github.com/abo-abo/hydra/wiki/multiple-cursors][here]]
- ivanmalison hydra example [[here]]
- github issue on setting run once to avoid exp behavior [[https://github.com/abo-abo/hydra/issues/327][here]]
- pull in phi-search as well to get incremental search while in mc
- protip: easy-kill ==C-SPC== will turn selection into region
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :config (progn
              (use-package phi-search-mc
                :ensure t
                :config
                (phi-search-mc/setup-keys)))
    (defhydra ava/multiple-cursors-hydra (:hint nil)
      "
   Up^^             Down^^           Miscellaneous           % 2(mc/num-cursors) cursor%s(if (> (mc/num-cursors) 1) \"s\" \"\")
  ------------------------------------------------------------------
   [_p_]   Next     [_n_]   Next     [_l_] Edit lines  [_d_] Mark sym defun  [_|_] Vertical align
   [_P_]   Skip     [_N_]   Skip     [_a_] Mark all    [_r_] Mark all regex  [_q_] Quit
   [_M-p_] Unmark   [_M-n_] Unmark   [_s_] Mark sym    [_0_] Insert numbers"
      ("n" mc/mark-next-like-this)
      ("N" mc/skip-to-next-like-this)
      ("M-n" mc/unmark-next-like-this)
      ("p" mc/mark-previous-like-this)
      ("P" mc/skip-to-previous-like-this)
      ("M-p" mc/unmark-previous-like-this)
      ("|" mc/vertical-align)
      ("0" mc/insert-numbers)
      ("l" mc/edit-beginnings-of-lines)
      ("a" mc/mark-all-like-this :exit t)
      ("s" mc/mark-all-symbols-like-this :exit t)
      ("d" mc/mark-all-symbols-like-this-in-defun :exit t)
      ("r" mc/mark-all-in-region-regexp :exit t)
      ("q" nil))
    :bind (("C-c i" . ava/multiple-cursors-hydra/body)
           :map mc/keymap ("C-s" . phi-search)))
#+END_SRC
** org-mode
*** org
#+BEGIN_SRC emacs-lisp
  (use-package org
    :custom
    (org-ellipsis " ▾")
    (org-use-speed-commands 1)
    (org-return-follows-link t)
    (org-blank-before-new-entry nil)
    (org-catch-invisible-edits 'smart)
    (org-enforce-todo-dependencies t)
    (org-hide-emphasis-markers t)
    (org-list-description-max-indent 5)
    (org-export-html-postamble nil)
    (org-log-done 'time)
    (org-cycle-separator-lines 0)
    (org-deadline-warning-days 7)
    (org-imenu-depth 10)
    (org-startup-folded t)
    (org-goto-auto-isearch nil)
    (org-refile-targets '((nil . (:maxlevel . 3))))
    (org-src-window-setup 'current-window)
    (org-log-into-drawer t)
    (org-todo-keywords '((sequence "TODO(t)" "WAIT(w@/!)" "|" "DONE(d)")))
    (org-highlight-latex-and-related '(native script entities))
    (org-confirm-babel-evaluate nil)
    (org-clock-history-length 20)
    (org-clock-out-remove-zero-time-clocks t)
    (org-link-elisp-confirm-function nil)
    :hook
    (org-mode . org-indent-mode)
    (org-mode . mixed-pitch-mode)
    :config
    (add-to-list 'org-speed-commands '("i" . (progn (outline-show-subtree) (org-end-of-subtree))))
    (add-to-list 'org-speed-commands '("b" . (unless (org-goto-sibling t) (while (org-goto-sibling)))))
    (add-to-list 'org-speed-commands '("f" . (unless (org-goto-sibling) (while (org-goto-sibling t)))))
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (shell . t)
       (R . t)
       (python . t)
       (dot . t)
       (plantuml . t)))
    (setq org-capture-bookmark nil
          org-capture-templates
          '(("n" "note" entry (file "notes.org") "* %? \n%U\n%i")
            ("t" "tasks")
            ("tt" "whenever" entry (file "todo.org") "* TODO %^{title}\n%?")
            ("ts" "schedule" entry (file "todo.org") "* TODO %^{title}\nSCHEDULED: %^t\n%?")
            ("td" "deadline" entry (file "todo.org") "* TODO %^{title}\nDEADLINE: %^t\n%?")
            ("ta" "sch&dead" entry (file "todo.org") "* TODO %^{title}\nSCHEDULED: %^t DEADLINE: %^t\n%?")))
    (define-key global-map (kbd "C-c l") 'org-store-link)
    (define-key global-map (kbd "C-c c") 'org-capture)
    (require 'org-tempo)
    (add-to-list 'org-structure-template-alist '("sh" . "src bash"))
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("py" . "src python"))
    (add-to-list 'org-structure-template-alist '("R" . "src R"))
    (dolist (face '((org-level-1 . 1.20) (org-level-2 . 1.10) (org-level-3 . 1.05)))
      (set-face-attribute (car face) nil :weight 'regular :height (cdr face))))
#+END_SRC
*** org-appear
hide emphasis markers the nice way
#+begin_src emacs-lisp
  (use-package org-appear
    :ensure t
    :commands (org-appear-mode)
    :hook (org-mode . org-appear-mode)
    :custom
    (org-appear-autoemphasis t)
    (org-appear-autokeywords t)
    (org-appear-autolinks t))
#+end_src
*** org-modern
#+BEGIN_SRC emacs-lisp
  (use-package org-modern
    :ensure t
    :hook ((org-mode . org-modern-mode)
           (org-agenda-finalize . org-modern-agenda))
    :custom
    (org-modern-star '("◉" "○" "●" "○" "●" "○" "●"))
    (org-modern-table-vertical 1)
    (org-modern-progress nil)
    (org-modern-block-fringe nil))
#+END_SRC
*** org-mime
#+BEGIN_SRC emacs-lisp
  (use-package org-mime
    :ensure t
    :config
    (setq mail-host-address (getenv "HOST")
          org-mime-export-options '(:section-numbers nil
                                    :with-author nil
                                    :with-toc nil
                                    :with-latex imagemagick))
    (add-hook 'message-mode-hook
              (lambda ()
                (local-set-key (kbd "C-c M-o") 'org-mime-htmlize)))
    (add-hook 'org-mode-hook
              (lambda ()
                (local-set-key (kbd "C-c M-o") 'org-mime-org-subtree-htmlize))))
#+END_SRC
*** orgit
#+begin_src emacs-lisp
  (use-package orgit :ensure t)
#+end_src
*** org-agenda
#+begin_src emacs-lisp
  (use-package org-agenda
    :after org
    :custom
    (org-agenda-files '("todo.org" "projects.org"))
    (org-agenda-span 'day)
    (org-agenda-window-setup 'current-window)
    (org-agenda-restore-windows-after-quit t)
    (org-agenda-todo-ignore-scheduled 'future)
    (org-agenda-skip-deadline-if-done t)
    (org-agenda-skip-scheduled-if-done t)
    (org-agenda-skip-deadline-prewarning-if-scheduled t)
    :init
    (global-set-key (kbd "C-c a") 'org-agenda))
#+end_src
*** org-projectile
#+begin_src emacs-lisp
  (use-package org-projectile
    :ensure t
    :after org
    :custom
    (org-projectile-capture-template "* TODO %^{title}\n%?")
    :config
    (add-to-list 'org-capture-templates (org-projectile-project-todo-entry :capture-heading "project todo")))
#+end_src

#+begin_src emacs-lisp
  (use-package helm-org :ensure t)
  (use-package org-projectile-helm
    :ensure t
    :after (org-projectile helm-org))
#+end_src
*** org-noter
#+begin_src emacs-lisp
  (use-package org-noter
   :ensure t
   :custom
   (org-noter-always-create-frame nil))
#+end_src
** pdf-tools
#+begin_src emacs-lisp
  (use-package pdf-tools
    :ensure t
    :custom
    (pdf-view-display-size 'fit-page)
    (pdf-view-continuous nil)
    :config
    (pdf-loader-install)
    (setq pdf-view-resize-factor 1.1)
    (add-hook 'pdf-tools-enabled-hook 'pdf-view-midnight-minor-mode))
#+end_src
** projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :custom
    (projectile-project-root-files-bottom-up '(".git" ".projectile"))
    ;; (projectile-project-root-files '("WORKSPACE"))
    :init
    (setq projectile-enable-caching t
          projectile-project-search-path '("~/development"))
    (when (executable-find "rg")
      (setq projectile-generic-command "rg -0 --hidden --files --color never"))
    :config
    (projectile-mode t)
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    (define-key projectile-mode-map (kbd "C-c p t") 'projectile-run-vterm)
    (define-key projectile-mode-map (kbd "C-c p S") 'helm-multi-swoop-projectile)
    (define-key projectile-mode-map (kbd "C-c p R") 'ava/generate-tags)
    (use-package helm-projectile
      :ensure t
      :init
      (helm-projectile-on)
      (setq projectile-switch-project-action #'helm-projectile)
      (setq projectile-completion-system 'helm)))
#+END_SRC
** python
make sure imenu does not override dumb-jump in python mode
#+begin_src emacs-lisp
  (use-package python
    :defer t
    :config
    (bind-key "C-c C-j" #'dumb-jump-go python-mode-map))
#+end_src

To use a venv set a pyvenv-activate directory local or file local variable to the venv path
(if one gets "exited abnormally with code 1" errors run =M-x elpy-rpc-reinstall-virtualenv=
as per https://github.com/jorgenschaefer/elpy/issues/1729)
#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :ensure t
    :commands elpy-enable
    :init
    (progn
      (elpy-enable)
      (setq elpy-modules
            '(elpy-module-sane-defaults
              elpy-module-company
              elpy-module-eldoc
              elpy-module-highlight-indentation
              elpy-module-pyvenv
              elpy-module-yasnippet
              elpy-module-folding))
      (eval-after-load "elpy"
        '(cl-dolist (key '("C-<return>" "C-<up>" "C-<down>" "C-<left>" "C-<right>"))
           (define-key elpy-mode-map (kbd key) nil)))
      :config
      (setq python-shell-interpreter "python")
      (setq python-shell-interpreter-args "-i")
      (setq elpy-rpc-python-command "python")
      (setq elpy-rpc-timeout 10)
      (setq python-shell-prompt-detect-failure-warning nil)
      (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
      (add-to-list 'process-coding-system-alist '("python" . (utf-8 . utf-8)))
      (add-hook 'elpy-mode-hook (lambda () (elpy-shell-toggle-dedicated-shell 1)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package python-black
    :ensure t
    :after (python)
    :config
    (setq python-black-command "/usr/bin/black")
    (define-key python-mode-map "\C-cb" 'python-black-buffer)
    (define-key python-mode-map "\C-cb" 'python-black-region))
#+END_SRC
** recentf
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :custom
    (recentf-max-saved-items 500)
    (recentf-auto-cleanup "05:00am")
    (recentf-exclude '(file-remote-p))
    :config
    (recentf-mode t))
#+END_SRC
** smart comment
#+begin_src emacs-lisp
  (use-package smart-comment
    :ensure t
    :bind ("M-;" . smart-comment))
#+end_src
** transpose frame
#+BEGIN_SRC emacs-lisp
  (use-package transpose-frame
    :ensure t
    :bind (("C-x |" . rotate-frame-clockwise)
           ("C-x \\" . rotate-frame-anticlockwise)))
#+END_SRC
** tree-sitter
references:
https://emacs-tree-sitter.github.io/installation/

#+begin_src emacs-lisp
  (use-package tree-sitter-langs :ensure t)

  (use-package tree-sitter
    :ensure t
    :after tree-sitter-langs
    :config
    (global-tree-sitter-mode)
    (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))
#+end_src
** undo-tree
A better non-linear undo
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :custom
    (undo-tree-auto-save-history nil)
    (undo-tree-enable-undo-in-region nil)
    (undo-tree-visualizer-diff t)
    (undo-tree-visualizer-timestamps t)
    (undo-tree-incompatible-major-modes '(term-mode vterm-mode))
    :config
    (global-undo-tree-mode))
#+END_SRC
** vlf
use for opening files larger than =large-file-warning-threshold=
#+BEGIN_SRC emacs-lisp
  (use-package vlf
    :ensure t
    :custom
    (vlf-save-in-place t)
    :config
    (require 'vlf-setup))
#+END_SRC
** vterm
#+BEGIN_SRC emacs-lisp
    (use-package vterm
      :ensure t
      :config
      (setq vterm-max-scrollback 100000)
      (define-key vterm-mode-map (kbd "C-c C-j") 'vterm-copy-mode))
#+END_SRC
start a remote vterm
#+BEGIN_SRC emacs-lisp
  (defun ava/rvterm (hos)
    "Start a dir-tracking vterm on hos (or host at point if host is nil)"
    (interactive "P")
    (let* ((host (or hos (thing-at-point 'sexp)))
           (user (getenv "USER"))
           (bname (format "*vterm %s*" host)))
      (vterm bname)
      (switch-to-buffer bname)
      (let* ((inhibit-read-only t)
             (sshcmd (format "ssh -Y %s@%s" user host))
             (fn1cmd "function vterm_printf() { \n printf \"\\e]%s\\e\\\\\" \"$1\" \n}")
             (fn2cmd "function vterm_prompt_end() { \n vterm_printf \"51;A$(whoami)@$(hostname):$(pwd)\" \n }")
             (ps1cmd "PS1=$PS1\'\\[$(vterm_promt_end)\\]\'")
             (bigcmd (format "%s\n%s\n%s\n%s\n" sshcmd fn1cmd fn2cmd ps1cmd)))
        (vterm-send-string bigcmd t))))
#+END_SRC
start a few common vterms
#+BEGIN_SRC emacs-lisp
  (defun ava/start-vterms ()
    "Start a few common vterms"
    (interactive)
    (let ((vterm-start-helper (lambda (name cmd)
                                (let ((bname (format "*vterm %s*" name)))
                                  (if (eq nil (get-buffer bname))
                                      (progn
                                        (vterm bname)
                                        (with-current-buffer bname
                                          (let ((inhibit-read-only t))
                                            (vterm-send-string (format "%s\n" cmd) t)))))))))
      (save-window-excursion
        (funcall vterm-start-helper "rand2" "")
        (funcall vterm-start-helper "rand1" "")
        (funcall vterm-start-helper "rand0" ""))))
#+END_SRC
** webjump
#+begin_src emacs-lisp
  (use-package webjump
    :bind (("C-c j" . webjump))
    :config
    (setq webjump-sites '(("Emacs Wiki" . [simple-query "www.emacswiki.org" "www.emacswiki.org/cgi-bin/wiki/" ""])
                          ("DuckDuckGo" .  [simple-query "duckduckgo.com" "duckduckgo.com/?q=" ""])
                          ("Google" .  [simple-query "www.google.com" "www.google.com/search?q=" ""])
                          ("Google Maps" . [simple-query "www.google.com/maps" "www.google.com/maps/search/" ""])
                          ("Wikipedia" .  [simple-query "wikipedia.org" "wikipedia.org/wiki/" ""])
                          ("AUR" . [simple-query "https://aur.archlinux.org" "https://aur.archlinux.org/packages/?O=0&K=" ""]))))
#+end_src
** wgrep
1. Execute one of the search commands like =projectile-ag=
2. Use =C-x C-s= to make permanent your search results to a buffer
3. Use =C-c C-p= within that result buffer to execute =wgrep-change-to-wgrep-mode= and now you can make edits to any lines you please (including regular emacs search-and-replace commands)
4. Use =C-c C-c= to save you changes, which will be promulgated to all files you’ve chosen to edit
#+begin_src emacs-lisp
  (use-package wgrep
    :ensure t
    :config (use-package wgrep-helm :ensure t))
#+end_src
** which key
show options for bindings in realtime
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :init
    (which-key-mode))
#+END_SRC
** with editor
magit uses this but can also use it to make crontab editing work from a running emacs
#+begin_src emacs-lisp
  (use-package with-editor
    :ensure t
    :config
    (defun ava/crontab ()
      "Run `crontab -e` from an emacs buffer"
      (interactive)
      (with-editor-async-shell-command "crontab -e")))
#+end_src
** wrap region
automatically encloses double quotes or parens
#+BEGIN_SRC emacs-lisp
  (use-package wrap-region
    :ensure t
    :config
    (wrap-region-global-mode t)
    (wrap-region-add-wrappers
     '(("*" "*" "*" org-mode)
       ("/" "/" "/" org-mode)
       ("~" "~" "~" org-mode)
       ("=" "=" "=" org-mode)))
    :diminish wrap-region-mode)
#+END_SRC
** ws-butler
advantage over =(add-hook 'before-save-hook #'delete-trailing-whitespace)= is that it does mess with others whitespace
#+begin_src emacs-lisp
  (use-package ws-butler
    :ensure t
    :hook
    (prog-mode . ws-butler-mode)
    (text-mode . ws-butler-mode))
#+end_src
** yasnippet
#+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :ensure t
      :diminish yas-minor-mode
      :commands (yas-minor-mode)
      :init
      (progn
        (add-hook 'ess-r-mode-hook #'yas-minor-mode)
        (add-hook 'python-mode-hook #'yas-minor-mode)
        (add-hook 'lisp-interaction-mode-hook #'yas-minor-mode)
        (add-hook 'emacs-lisp-mode-hook #'yas-minor-mode)
        (add-hook 'c++-mode-hook #'yas-minor-mode)
        (add-hook 'c-mode-hook #'yas-minor-mode))
      :config
      (use-package yasnippet-snippets
        :ensure t)
      (yas-reload-all))
#+END_SRC
** ztree
nice directory level diffing
#+BEGIN_SRC emacs-lisp
  (use-package ztree
    :ensure t
    :commands ztree-diff
    :bind (:map ztree-mode-map
                ("j" . ztree-jump-side)))
#+END_SRC
* inactive packages
** dmenu
to launch applications from exwm (not in use)
#+BEGIN_SRC emacs-lisp
;;(use-package dmenu
;;  :ensure t
;;  :bind
;;  ("s-SPC" . dmenu))
#+END_SRC
** clojure
#+BEGIN_SRC emacs-lisp
;  (use-package clojure-mode
;    :ensure t
;    :mode
;    (("\\.clj.*$" . clojure-mode)
;     ("\\.edn.*$" . clojure-mode))
;    :init
;    (add-hook 'clojure-mode-hook #'yas-minor-mode)
;    (add-hook 'clojure-mode-hook #'paredit-mode)
;    (add-hook 'clojure-mode-hook #'eldoc-mode))
;
;  ;pulls cider
;  (use-package clj-refactor
;    :ensure t
;    :defer t
;    :diminish clj-refactor-mode
;    :config
;    (setq cljr-warn-on-eval nil)
;    (cljr-add-keybindings-with-prefix "C-c C-m"))
;
;  (use-package cider
;    :ensure t
;    :defer t
;    :init
;    (add-hook 'cider-mode-hook #'clj-refactor-mode)
;    (add-hook 'cider-repl-mode-hook #'paredit-mode)
;    :config
;    (setq cider-repl-use-clojure-font-lock t
;          cider-overlays-use-font-lock t
;          cider-repl-display-help-banner nil
;          cider-repl-pop-to-buffer-on-connect nil
;          ;nrepl-log-messages t
;          ;cider-preferred-build-tool "boot" ;(if no lein)
;          ;cider-prompt-save-file-on-load 'always-save
;          ;cider-font-lock-dynamically '(macro core function var)
;          ;nrepl-hide-special-buffers t
;          )
;    (cider-repl-toggle-pretty-printing))
#+END_SRC
** eaf
Disabled as not snappy enough
[[https://aur.archlinux.org/packages/emacs-eaf/][emacs-eaf AUR]]
[[https://github.com/manateelazycat/emacs-application-framework][github]]
#+BEGIN_SRC emacs-lisp
;  (use-package eaf
;    :load-path "/usr/share/emacs/site-lisp/eaf"
;    :custom
;    (eaf-find-alternate-file-in-dired t)
;    (browse-url-browser-function 'eaf-open-browser)
;    :config
;    (eaf-setq eaf-pdf-default-zoom 1.25)
;    (eaf-setq eaf-browser-enable-adblocker "true")
;    (eaf-bind-key nil "SPC" eaf-browser-keybinding)
;    (eaf-bind-key nil "p" eaf-browser-keybinding)
;    (defun adviser-find-file (orig-fn file &rest args)
;      (let ((fn (if (commandp 'eaf-open) 'eaf-open orig-fn)))
;        (pcase (file-name-extension file)
;          ("pdf"  (apply fn file nil))
;          ("epub" (apply fn file nil))
;          (_      (apply orig-fn file args)))))
;    (advice-add #'find-file :around #'adviser-find-file))
#+END_SRC
** elfeed
#+BEGIN_SRC emacs-lisp
;  (use-package elfeed
;    :disabled
;    :ensure   t
;    :commands elfeed
;    :config
;    (setq-default elfeed-search-filter "@1-week-ago ")
;    (setq elfeed-feeds
;          '(("https://www.archlinux.org/feeds/news/" arch)
;            ("http://www.reddit.com/r/emacs/.rss" emacs reddit)
;            ("http://sachachua.com/blog/category/emacs-news/feed" emacs sacha)
;            ("http://endlessparentheses.com/atom.xml" emacs)
;            ("http://www.masteringemacs.org/feed/" emacs)
;            ("http://emacs-fu.blogspot.com/feeds/posts/default" emacs)
;            ("http://emacsredux.com/atom.xml" emacs)
;            ("http://arxiv.org/rss/q-fin.TR" arxiv trading)
;            ("http://feeds.feedburner.com/zerohedge/feed"))
;            )
;    )
#+END_SRC
** exwm
comment out for now as not in use
#+BEGIN_SRC emacs-lisp
  ;;(use-package exwm :ensure t
  ;;  :init
  ;;  :config
  ;;  (setq exwm-workspace-number 4)
  ;;  (defun exwm-rename-buffer-to-title () (exwm-workspace-rename-buffer exwm-title))
  ;;  (add-hook 'exwm-update-title-hook 'exwm-rename-buffer-to-title)
  ;;  (exwm-input-set-key (kbd "s-r") #'exwm-reset)
  ;;  (exwm-input-set-key (kbd "s-w") #'exwm-workspace-switch)
  ;;  (dotimes (i 10)
  ;;    (exwm-input-set-key (kbd (format "s-%d" i))
  ;;                        `(lambda ()
  ;;                           (interactive)
  ;;                           (exwm-workspace-switch-create ,i))))
  ;;  (exwm-input-set-key (kbd "s-&")
  ;;                      (lambda (command)
  ;;                        (interactive (list (read-shell-command "$ ")))
  ;;                        (start-process-shell-command command nil command)))
  ;;  (setq exwm-input-simulation-keys
  ;;        '(([?\C-b] . [left])
  ;;          ([?\C-f] . [right])
  ;;          ([?\C-p] . [up])
  ;;          ([?\C-n] . [down])
  ;;          ([?\C-a] . [home])
  ;;          ([?\C-e] . [end])
  ;;          ([?\M-v] . [prior])
  ;;          ([?\C-v] . [next])
  ;;          ([?\C-d] . [delete])
  ;;          ([?\C-k] . [S-end delete])
  ;;          ([?\C-s] . [?\C-f])
  ;;          ([?\C-t] . [?\C-n])))
  ;;  (exwm-enable)
  ;;  )
#+END_SRC
** fancy narrow
replaces default narrow (slow so not in use)
#+BEGIN_SRC emacs-lisp
;  (use-package fancy-narrow
;    :ensure t
;    :init
;    (fancy-narrow-mode)
;    :diminish fancy-narrow-mode)
#+END_SRC
** iedit
#+BEGIN_SRC emacs-lisp
;  (use-package iedit
;    :ensure t
;    :bind ("C-;" . iedit-mode)
;    :config
;    (setq iedit-toggle-key-default nil)
;    (define-key iedit-mode-occurrence-keymap (kbd "RET") 'iedit-mode)
;    :diminish)
#+END_SRC
** irony
Also run ~M-x irony-install-server~ which just needs cmake, libclang, and llvm libs
Disabled in favor of trying LSP
#+BEGIN_SRC emacs-lisp
;    (use-package irony
;      :disabled
;      :ensure t
;      :init
;      (add-hook 'c++-mode-hook 'irony-mode)
;      (add-hook 'c-mode-hook 'irony-mode)
;      (add-hook 'objc-mode-hook 'irony-mode)
;      (setq-default irony-cdb-compilation-databases '(irony-cdb-libclang
;                                                      irony-cdb-json
;                                                      irony-cdb-clang-complete))
;      :bind (:map irony-mode-map
;                  ("C-c t" . irony-get-type))
;      :config
;      (defun ava/irony-mode-hook ()
;        (define-key irony-mode-map [remap completion-at-point]
;          'irony-completion-at-point-async)
;        (define-key irony-mode-map [remap complete-symbol]
;          'irony-completion-at-point-async))
;      (add-hook 'irony-mode-hook 'ava/irony-mode-hook)
;      (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
;      (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)
;      (add-hook 'irony-mode-hook #'irony-eldoc)
;      (use-package irony-eldoc
;        :ensure t))
#+END_SRC
** leetcode
on MELPA from here [[https://github.com/kaiwk/leetcode][leetcode]]
#+BEGIN_SRC emacs-lisp
;  (use-package leetcode
;    :disabled
;    :ensure t
;    :config
;    (setq leetcode-prefer-language "cpp")
;    (setq leetcode-prefer-sql "mysql"))
#+END_SRC
** mu4e
The smtp portion will require app specific password and will store it in ~/.authinfo after first use
#+BEGIN_SRC emacs-lisp
  ;; (use-package mu4e
  ;;   :load-path "/usr/share/emacs/site-lisp/mu4e"
  ;;   :config
  ;;   (setq mu4e-maildir (expand-file-name "~/mbsync"))
  ;;   (setq mu4e-sent-folder "/sent")
  ;;   (setq mu4e-drafts-folder "/drafts")
  ;;   (setq mu4e-trash-folder "/trash")

  ;;   ;;GMail/IMAP takes care of this
  ;;   (setq mu4e-sent-messages-behavior 'delete)
  ;;   (setq mu4e-get-mail-command "mbsync -q gmail")
  ;;   (setq mu4e-update-interval 3600)
  ;;   (setq mu4e-maildir-shortcuts
  ;;   '(("/INBOX" . ?i)
  ;;     ("/sent" . ?s)))
  ;;   (setq mu4e-view-show-images t)
  ;;   (setq mu4e-use-fancy-chars t)
  ;;   (setq mu4e-view-show-addresses t)
  ;;   (setq mu4e-headers-show-threads nil)
  ;;   )
  ;; (require 'smtpmail)
  ;; (setq message-send-mail-function 'smtpmail-send-it
  ;;       user-mail-address "email_username@gmail.com"
  ;;       smtpmail-smtp-user "email_username"
  ;;       smtpmail-local-domain "gmail.com"
  ;;       smtpmail-default-smtp-server "smtp.gmail.com"
  ;;       smtpmail-smtp-server "smtp.gmail.com"
  ;;       smtpmail-smtp-service 587)
#+END_SRC

a second reference setup (works with outlook)
#+begin_src emacs-lisp
;;  (use-package mu4e
;;    :load-path "path/to/mu4e/lisp"
;;    :bind (("C-c 2" . mu4e))
;;    :custom
;;    (mu4e-mu-home "/path/to/mu/index/if/not/homedir")
;;    (mu4e-mu-binary "path/to/mu/binary/if/not/in/path")
;;    (mu4e-sent-folder "/sent")
;;    (mu4e-drafts-folder "/drafts")
;;    (mu4e-trash-folder "/trash")
;;    (mu4e-get-mail-command "mbsync -q work")
;;    (mu4e-update-interval 180)
;;    (mu4e-sent-messages-behavior 'delete)
;;    (mu4e-maildir-shortcuts '(("/Inbox" . ?i) ("/sent" . ?s)))
;;    :config
;;    (setq mu4e-headers-show-threads nil)
;;    (setq mail-user-agent 'mu4e-user-agent) ;C-x m uses mu4e
;;    (progn ; SMTP
;;      (require 'smtpmail)
;;      (setq message-send-mail-function 'smtpmail-send-it
;;            smtpmail-default-smtp-server "foo.com"
;;            smtpmail-smtp-server "foo.com"))
;;    (progn ; Calendar
;;      (require 'mu4e-icalendar)
;;      (mu4e-icalendar-setup)
;;      (setq gnus-icalendar-org-capture-file "~/calendar.org"
;;            gnus-icalendar-org-capture-headline '("calendar"))
;;      (gnus-icalendar-org-setup)))
#+end_src
** rmsbolt
#+BEGIN_SRC emacs-lisp
;  (use-package rmsbolt
;    :disabled
;    :ensure t)
#+END_SRC
** speed typing
#+BEGIN_SRC emacs-lisp
;  (use-package speed-type
;    :ensure t
;    :disabled
;    :commands (speed-type-text))
#+END_SRC
** switch window
#+BEGIN_SRC emacs-lisp
;;  (use-package switch-window
;;    :ensure t
;;    :bind (("C-x o" . switch-window))
;;    :config
;;    (setq switch-window-shortcut-style 'qwerty)
;;    (setq switch-window-qwerty-shortcuts '("a" "s" "d" "f" "j" "k" "l" "w" "e" "i" "o"))
;    (setq switch-window-minibuffer-shortcut ?z))
#+END_SRC
** telega
Telegram support from emacs (needs visual-fill-column)
#+BEGIN_SRC emacs-lisp
;  (use-package visual-fill-column :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;      (require 'notifications)
;      (use-package telega
;        :disabled
;        :load-path "~/3rdParty/telega/"
;        :commands (telega)
;        :config
;        (setq telega-use-notifications t)
;        (add-hook 'telega-chat-mode-hook (lambda ()
;                                           (setq company-backends '(telega-company-emoji))
;                                           (company-mode 1)))
;        :defer t)
#+END_SRC
** term
make line-mode the default for terms and allow bigger buffer size
#+BEGIN_SRC emacs-lisp
;  (setq term-buffer-maximum-size 262144)
;  (defun ava/default-term-line-mode (&ret ignore) (term-line-mode))
;  (advice-add 'ansi-term :after #'ava/default-term-line-mode)
#+END_SRC
ansi-term defaults to bash
#+BEGIN_SRC emacs-lisp
;(defvar my-term-shell "/bin/bash")
;(defadvice ansi-term (before force-bash)
;  (interactive (list my-term-shell)))
;(ad-activate 'ansi-term)
#+END_SRC
start a remote term =https://www.emacswiki.org/emacs/AnsiTermHints#toc4=
#+BEGIN_SRC emacs-lisp
;  (defun ava/raterm ()
;    (interactive)
;    (setq user (read-string "User: "))
;    (setq host (read-string "Host: "))
;    (setq term-ansi-buffer-name (concat "term " host))
;    (setq term-ansi-buffer-name (generate-new-buffer-name term-ansi-buffer-name))
;    (setq term-ansi-buffer-name (apply 'make-term term-ansi-buffer-name "ssh" nil (list (concat user "@" host))))
;    (set-buffer term-ansi-buffer-name)
;    (term-mode)
;    (term-line-mode)
;    (term-set-escape-char ?\C-x)
;    (switch-to-buffer term-ansi-buffer-name)
;    (insert "function set-eterm-dir { \n echo -e \"\\033AnSiTu\" \"$LOGNAME\" \n echo -e \"\\033AnSiTc\" \"$(pwd)\" \n echo -e \"\\033AnSiTh\" \"$(hostname -f)\" \n history -a \n }")
;    (insert "\nPROMPT_COMMAND=set-eterm-dir\n")
;    (term-send-input))
#+END_SRC
start a few common terms
#+BEGIN_SRC emacs-lisp
;  (defun ava/start-ansi-terms ()
;    "Start a few common ansi terms"
;    (interactive)
;    (let ((term-start-helper (lambda (name cmd)
;                               (ansi-term "/bin/bash" (format "bash.%s" name))
;                               (with-current-buffer (format "*bash.%s*" name)
;                                 (insert (format "%s\n" cmd))
;                                 (term-send-input)))))
;      (save-window-excursion
;        ;only shells for now
;        (funcall term-start-helper "rand0" "")
;        (funcall term-start-helper "rand1" "")
;        (funcall term-start-helper "rand2" ""))))
#+END_SRC
** visual-fill-column
reference: [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]] (to center code in wide monitors)

#+begin_src emacs-lisp
;  (defun ava/visual-fill-column-and-center ()
;    (setq visual-fill-column-center-text t
;          visual-fill-column-width 134)
;    (visual-fill-column-mode 1))
;
;  (use-package visual-fill-column
;    :hook (prog-mode . ava/visual-fill-column-and-center))
#+end_src
