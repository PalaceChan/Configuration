* startup
** theme
#+BEGIN_SRC emacs-lisp
(use-package doom-themes :ensure t :defer t)
(load-theme 'doom-one t)
(set-frame-font "Inconsolata-13")
(global-font-lock-mode t)
(setq font-lock-maximum-decoration t)
#+END_SRC
** start
Disable a bunch of visuals
#+BEGIN_SRC emacs-lisp
(menu-bar-mode 0)
(tool-bar-mode 0)
(scroll-bar-mode 0)
(transient-mark-mode 1)
#+END_SRC
Disable startup messages and text in scratch
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t
  inhibit-startup-echo-area-message t
  initial-scratch-message nil)
#+END_SRC
** warnings
Disable common warnings
#+BEGIN_SRC emacs-lisp
(put 'set-goal-column 'disabled nil)
(put 'upcase-region 'disabled nil)
(put 'narrow-to-region 'disabled nil)
(put 'erase-buffer 'disabled nil)
(put 'downcase-region 'disabled nil)
(setq large-file-warning-threshold nil)
#+END_SRC
** basic settings
#+BEGIN_SRC emacs-lisp
(setq scroll-step 1)
(setq grep-highlight-matches t)
(setq shell-file-name "bash")
(setq x-alt-keysym 'meta)
(setq kill-ring-max 100)
(require 'dired-x)
(setq dired-listing-switches "-Al --si --time-style long-iso --group-directories-first")
(setq term-buffer-maximum-size 262144)
(setq undo-outer-limit 50000000)
(setq make-backup-files nil)
(show-paren-mode t)
(setq browse-url-browser-function 'eww-browse-url)
(add-to-list 'same-window-buffer-names "*Buffer List*")
(add-to-list 'same-window-buffer-names "*grep*")
(setq gc-cons-threshold (* 20 1000 1000))
#+END_SRC
** save history
Save some history across sessions. (savehist-mode) on auto-save can be slow so we rely on desktop-save instead
#+BEGIN_SRC emacs-lisp
  (setq history-length 800)
  (setq history-delete-duplicates t)
  (desktop-save-mode -1)
  (setq desktop-globals-to-save
        (append
         '(desktop-missing-file-waning
           (shell-command-history 800)
           tags-file-name tags-table-list
           (search-ring . 800) (regexp-search-ring . 800)
           register-alist file-name-history (kill-ring . 8000)
           (minibuffer-history . 800) query-replace-history regexp-history)))
#+END_SRC
** mode bar
show battery, column number and nicely formatted time
#+BEGIN_SRC emacs-lisp
(setq column-number-mode t)
(setq display-time-24hr-format t)
(setq display-time-format "%H:%M - %Y%m%d")
(display-battery-mode t)
(display-time-mode 1)
#+END_SRC
** highlighting
#+BEGIN_SRC emacs-lisp
(global-hi-lock-mode 1)
(setq hi-lock-auto-select-face t)
#+END_SRC
** emacs server
#+BEGIN_SRC emacs-lisp
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+END_SRC
** misc
override default timezones for the world clock view
#+BEGIN_SRC emacs-lisp
(setq display-time-world-list '(
                                ("America/Chicago" "Chicago") ("Asia/Tokyo" "Japan")
                                ("Europe/Berlin" "Frankfurt") ("Australia/Sydney" "Australia") ))
#+END_SRC
winner mode enabled to pop a stack of window configurations
#+BEGIN_SRC emacs-lisp
  (use-package winner
    :bind (("M-N" . winner-redo)
           ("M-P" . winner-undo))
    :config
    (winner-mode 1))
#+END_SRC
make line-mode the default for terms
#+BEGIN_SRC emacs-lisp
  (defun ava/default-term-line-mode (&ret ignore) (term-line-mode))
  (advice-add 'ansi-term :after #'ava/default-term-line-mode)
#+END_SRC
* shortcuts
ansi-term defaults to bash
#+BEGIN_SRC emacs-lisp
(defvar my-term-shell "/bin/bash")
(defadvice ansi-term (before force-bash)
  (interactive (list my-term-shell)))
(ad-activate 'ansi-term)
#+END_SRC
aliases and global bindings
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
(global-set-key (kbd "C-x l") 'align-regexp)
#+END_SRC
* development
** general
#+BEGIN_SRC emacs-lisp
(setq indent-tabs-mode nil)
(setq tab-width 4)
#+END_SRC
** tags
generation of TAGS covered by =scripts/updateTagsAndDb.py= on [[https://github.com/PalaceChan/][GitHub]]
#+BEGIN_SRC emacs-lisp
(setq tags-file-name "~/rabbit/tags/TAGS")
#+END_SRC
** semantic mode
use semantic without it interfering with completion and without auto-parsing in idle time
(only use it for helm-semantic-or-imenu and thus parses buffer on demand)
#+BEGIN_SRC emacs-lisp
  (require 'semantic)
  (add-hook 'semantic-mode-hook
            (lambda ()
              (dolist (x (default-value 'completion-at-point-functions))
                (when (string-prefix-p "semantic-" (symbol-name x))
                  (remove-hook 'completion-at-point-functions x)))))
  (setq semantic-default-submodes '(global-semanticdb-minor-mode))
  (semantic-mode 1)
#+END_SRC
** c/c++
indentation related
#+BEGIN_SRC emacs-lisp
(setq c-default-style "linux"
      c-basic-offset 4)
(c-set-offset 'innamespace 0)
#+END_SRC
toggle between implementation and header
#+BEGIN_SRC emacs-lisp
(setq cc-search-directories
'( "/usr/include" "/usr/include/sys" "/usr/include/linux"
   "."
  )
)
(setq cc-other-file-alist
'(("\\.cpp$" (".h" ".hpp"))
("\\.h$" (".cpp" ".c"))
("\\.hpp$" (".cpp" ".c"))
("\\.C$" (".H"))
("\\.H$" (".C"))
))
(add-hook 'c-mode-common-hook (lambda() (global-set-key (kbd "C-c o") 'ff-find-other-file)))
#+END_SRC

** compilation
#+BEGIN_SRC emacs-lisp
(setq compile-command "make")
(setq compilation-read-command nil)
#+END_SRC
* custom functions
kill current buffer no prompt
#+BEGIN_SRC emacs-lisp
(defun kill-current-buffer ()
  "Kill the current buffer, without confirmation."
  (interactive)
  (kill-buffer (current-buffer)))
(global-set-key "\C-xk" 'kill-current-buffer)
#+END_SRC
copies current filename to kill-ring
#+BEGIN_SRC emacs-lisp
  (defun ava/copy-fname-to-killring (&optional arg)
    "Copy current filename (basename) to kill ring. Full name if called with prefix arg"
    (interactive "P")
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (if arg
                          (buffer-file-name)
                        (file-name-nondirectory (buffer-file-name))
                        )
                      )))
      (when filename)
      (kill-new filename)
      (message "%s copied to kill ring." filename)))
#+END_SRC
start a few common terms
#+BEGIN_SRC emacs-lisp
  (defun ava/start-ansi-terms ()
    "Start a few common ansi terms"
    (interactive)
    (let ((term-start-helper (lambda (name cmd)
                               (ansi-term "/bin/bash" (format "bash.%s" name))
                               (with-current-buffer (format "*bash.%s*" name)
                                 (insert (format "%s\n" cmd))
                                 (term-send-input)))))
      (save-window-excursion
        ;only main shell for now
        (funcall term-start-helper "main" ""))))
#+END_SRC
* undo-tree
A better non-linear undo
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :config
    (setq undo-tree-visualizer-diff t
          undo-tree-visualizer-timestamps t)
    (global-undo-tree-mode))
#+END_SRC
* exwm
comment out for now as not in use
#+BEGIN_SRC emacs-lisp
  ;;(use-package exwm :ensure t
  ;;  :init
  ;;  :config
  ;;  (setq exwm-workspace-number 4)
  ;;  (defun exwm-rename-buffer-to-title () (exwm-workspace-rename-buffer exwm-title))
  ;;  (add-hook 'exwm-update-title-hook 'exwm-rename-buffer-to-title)
  ;;  (exwm-input-set-key (kbd "s-r") #'exwm-reset)
  ;;  (exwm-input-set-key (kbd "s-w") #'exwm-workspace-switch)
  ;;  (dotimes (i 10)
  ;;    (exwm-input-set-key (kbd (format "s-%d" i))
  ;;                        `(lambda ()
  ;;                           (interactive)
  ;;                           (exwm-workspace-switch-create ,i))))
  ;;  (exwm-input-set-key (kbd "s-&")
  ;;                      (lambda (command)
  ;;                        (interactive (list (read-shell-command "$ ")))
  ;;                        (start-process-shell-command command nil command)))
  ;;  (setq exwm-input-simulation-keys
  ;;        '(([?\C-b] . [left])
  ;;          ([?\C-f] . [right])
  ;;          ([?\C-p] . [up])
  ;;          ([?\C-n] . [down])
  ;;          ([?\C-a] . [home])
  ;;          ([?\C-e] . [end])
  ;;          ([?\M-v] . [prior])
  ;;          ([?\C-v] . [next])
  ;;          ([?\C-d] . [delete])
  ;;          ([?\C-k] . [S-end delete])
  ;;          ([?\C-s] . [?\C-f])
  ;;          ([?\C-t] . [?\C-n])))
  ;;  (exwm-enable)
  ;;  )
#+END_SRC
* dmenu
to launch applications from exwm (not in use)
#+BEGIN_SRC emacs-lisp
;;(use-package dmenu
;;  :ensure t
;;  :bind
;;  ("s-SPC" . dmenu))
#+END_SRC
* helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
               :demand t
               :diminish helm-mode
               :init
               (progn
                 (require 'helm-config)
                 (setq helm-candidate-number-limit 100)
                 (setq helm-idle-delay 0.0
                       helm-input-idle-delay 0.01
                       helm-yas-display-key-on-candidate t
                       helm-quick-update t
                       helm-M-x-requires-pattern nil)
                 (helm-mode)
                 )
               :bind (
                      ("C-h a" . helm-apropos)
                      ("C-x C-b" . helm-buffers-list)
                      ("C-x b" . helm-buffers-list)
                      ("M-y" . helm-show-kill-ring)
                      ("M-x" . helm-M-x)
                      ("C-x C-f" . helm-find-files)
                      ("C-c h o" . helm-occur)
                      ("C-c h r" . helm-register)
                      ("C-c h b" . helm-resume)
                      )
               :config
               (setq helm-command-prefix-key "C-c h")
               (setq helm-autoresize-min-height 25)
               (setq helm-autoresize-max-height 25)
               (setq helm-split-window-in-side-p t
                     helm-move-to-line-cycle-in-source t
                     helm-ff-search-library-in-sexp t
                     helm-scroll-amount 8
                     helm-ff-file-name-history-use-recentf t)
               (setq helm-buffer-max-length nil)
               ;;locate %s -d FOO -e --regex %s where FOO is : delimited from cmd updatedb -l 0 -o i.db -U path_i for all paths
               ;;(defvar my-locate-db-command (with-temp-buffer (insert-file-contents "path/to/cmd.txt") (buffer-string)))
               ;;(setq helm-locate-command my-locae-db-command)
               (helm-mode 1)
               (helm-autoresize-mode 1)
               (define-key  helm-map (kbd "<tab>") 'helm-execute-persistent-action)
               (define-key  helm-map (kbd "C-i") 'helm-execute-persistent-action)
               (define-key  helm-map (kbd "C-z") 'helm-select-action)
               :ensure helm)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package helm-swoop
    :ensure t
    :bind (("C-c h s" . helm-multi-swoop))
    :init
    (bind-key "M-i" 'helm-swoop-from-isearch isearch-mode-map)
    :config
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-current-mode-from-helm-swoop)
    )

  (use-package helm-ag :ensure t)
  (use-package helm-rg :ensure t)
#+END_SRC
* avy
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :bind (("M-g c" . avy-goto-char-timer)
           ("M-g M-g" . avy-goto-line))
    :config
    (setq avy-timeout-seconds 0.3)
    (when (display-graphic-p) (setq avy-background t))
    )
#+END_SRC
* switch window
#+BEGIN_SRC emacs-lisp
  (use-package switch-window
    :ensure t
    :bind (
           ("C-x o" . switch-window)
           )
    :config
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-qwerty-shortcuts '("a" "s" "d" "f" "j" "k" "l" "w" "e" "i" "o"))
    (setq switch-window-minibuffer-shortcut ?z)
    )
#+END_SRC
* company
Including ~company-irony~ and ~company-c-headers~
** general company
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (setq company-idle-delay nil)
    (setq company-dabbrev-downcase nil)
    (setq company-show-numbers t)
    (setq company-tooltip-limit 20)
    (setq company-backends
          '((company-files company-keywords company-capf company-dabbrev-code company-gtags company-etags)
            company-clang
            (company-abbrev company-dabbrev)))
    (add-hook 'after-init-hook 'global-company-mode)
    ;; TODO fix not being able to use C-n and C-p
    (define-key company-active-map (kbd "M-n") nil)
    (define-key company-active-map (kbd "M-p") nil)
    (define-key company-active-map (kbd "M-j") 'company-select-previous)
    (define-key company-active-map (kbd "M-k") 'company-select-next)
    ;; setup tab to manually trigger company completion
    (define-key company-mode-map (kbd "TAB") 'company-indent-or-complete-common)
    (define-key company-active-map (kbd "TAB") 'company-complete-common)
    ;; setup M-h to show documentation for items on the autocomplete menu
    (define-key company-active-map (kbd "M-h") 'company-show-doc-buffer)
    (setq company-global-modes '(not term-mode compilation-mode magit-status-mode))
    (use-package company-irony
      :ensure t
      :config
      (setq company-irony-ignore-case 'smart)
      (add-to-list 'company-backends 'company-irony)
      (use-package company-c-headers
        :ensure t
        :functions irony--extract-user-search-paths company-c-headers
        :preface
        (defun company-c-headers-path-user-irony ()
          "Return the user include paths for the current buffer."
          (when irony-mode
            (irony--extract-user-search-paths irony--compile-options
                                              irony--working-directory)))
        :config
        (setq company-c-headers-path-user #'company-c-headers-path-user-irony)
        (add-to-list 'company-backends #'company-c-headers))))
#+END_SRC
** helm company (unmantained but pretty neat)
#+BEGIN_SRC emacs-lisp
  (use-package helm-company
    :ensure t
    :config
    (progn
      (define-key company-mode-map (kbd "C-:") 'helm-company)
      (define-key company-active-map (kbd "C-:") 'helm-company)))
#+END_SRC
* irony
Also run ~M-x irony-install-server~ which just needs cmake, libclang, and llvm libs
#+BEGIN_SRC emacs-lisp
    (use-package irony
      :ensure t
      :init
      (add-hook 'c++-mode-hook 'irony-mode)
      (add-hook 'c-mode-hook 'irony-mode)
      (add-hook 'objc-mode-hook 'irony-mode)
      (setq-default irony-cdb-compilation-databases '(irony-cdb-libclang
                                                      irony-cdb-json
                                                      irony-cdb-clang-complete))
      :bind (:map irony-mode-map
                  ("C-c t" . irony-get-type))
      :config
      (defun ava/irony-mode-hook ()
        (define-key irony-mode-map [remap completion-at-point]
          'irony-completion-at-point-async)
        (define-key irony-mode-map [remap complete-symbol]
          'irony-completion-at-point-async))
      (add-hook 'irony-mode-hook 'ava/irony-mode-hook)
      (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
      (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)
      (add-hook 'irony-mode-hook #'irony-eldoc)
      (use-package irony-eldoc
        :ensure t))
#+END_SRC
* yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode
    :commands (yas-minor-mode)
    :init
    (progn 
      (add-hook 'ess-r-mode-hook #'yas-minor-mode)
      (add-hook 'python-mode-hook #'yas-minor-mode)
      (add-hook 'lisp-interaction-mode-hook #'yas-minor-mode)
      (add-hook 'emacs-lisp-mode-hook #'yas-minor-mode)
      (add-hook 'c++-mode-hook #'yas-minor-mode))
    :config
    (use-package yasnippet-snippets
      :ensure t)
    (yas-reload-all))
#+END_SRC
* org
use bullet mode
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+END_SRC
now configure org (default installed)
#+BEGIN_SRC emacs-lisp
    (setq org-use-speed-commands 1)
    (setq org-list-description-max-indent 5)
    (setq org-export-html-postamble nil)
    (setq org-log-done 'note)

    (add-hook 'org-mode-hook 'org-indent-mode)

    (setq org-confirm-babel-evaluate nil)
    (org-babel-do-load-languages 'org-babel-load-languages '( (emacs-lisp . t) (shell . t) (R . t) ))

    (global-set-key (kbd "C-c a") 'org-agenda)
    (setq org-agenda-files (quote ("~/todo.org")))
    (setq org-agenda-window-setup (quote current-window))

    (define-key global-map (kbd "C-c l") 'org-store-link)
    (define-key global-map (kbd "C-c c") 'org-capture)
    (setq org-capture-templates 
          '(("t" "Todo" entry (file+headline "~/todo.org" "Tasks")
             "* TODO %?")
            ("l" "Link" entry (file+headline "~/todo.org" "Links")
             "* %^L %? %^g")))
#+END_SRC
* dired related
a much nicer dired (can in-place expand subdirectory contents)
#+BEGIN_SRC emacs-lisp
(use-package dired-subtree
             :config
             (define-key dired-mode-map "i" 'dired-subtree-insert)
             (define-key dired-mode-map ";" 'dired-subtree-remove)
             :ensure dired-subtree)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package dired-git-info
    :ensure t
    :bind (:map dired-mode-map (")" . dired-git-info-mode))
    :config
    (setq dgi-commit-message-format "%f\t%an\t%cr"))
#+END_SRC
* ztree
nice directory level diffing
#+BEGIN_SRC emacs-lisp
  (use-package ztree
    :ensure t
    :commands ztree-diff
    :bind (:map ztree-mode-map
                ("j" . ztree-jump-side)))
#+END_SRC
* wrap region
automatically encloses double quotes or parens
#+BEGIN_SRC emacs-lisp
(use-package wrap-region
  :ensure t
  :config (wrap-region-global-mode t)
  :diminish wrap-region-mode)
#+END_SRC
* expand region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :commands er/expand-region
    :bind ("C-=" . er/expand-region)
    )
#+END_SRC
* easy kill
Use ~M-w~ and modifiers to more efficiently save things to kill ring
#+BEGIN_SRC emacs-lisp
  (use-package easy-kill
  :ensure t
  :config
  (global-set-key [remap kill-ring-save] #'easy-kill))
#+END_SRC
* fancy narrow
replaces default narrow
#+BEGIN_SRC emacs-lisp
  (use-package fancy-narrow
    :ensure t
    :init
    (fancy-narrow-mode)
    :diminish fancy-narrow-mode)
#+END_SRC
* which key
show options for bindings in realtime
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :init
  (which-key-mode))
#+END_SRC
* transpose frame
#+BEGIN_SRC emacs-lisp
  (use-package transpose-frame
    :ensure t
    :bind (
           ("C-x |" . rotate-frame-clockwise)
           ("C-x \\" . rotate-frame-anticlockwise)
           )
    )
#+END_SRC
* hydra
great for git-gutter
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure hydra
    :init
    (global-set-key
     (kbd "C-c g")
     (defhydra hydra-git-gutter (:body-pre (git-gutter-mode 1)
                                           :hint nil)
       ("n" git-gutter:next-hunk "next hunk")
       ("p" git-gutter:previous-hunk "previous hunk")
       ("h" (progn (goto-char (point-min)) (git-gutter:next-hunk 1)) "first hunk")
       ("l" (progn (goto-char (point-min)) (git-gutter:previous-hunk 1)) "last hunk")
       ("<SPC>" git-gutter:popup-hunk "popup hunk")
       ("s" git-gutter:stage-hunk "stage hunk")
       ("r" git-gutter:revert-hunk "revert hunk")
       ("q" nil "quit")))

    (global-set-key
     (kbd "C-c e")
     (defhydra hydra-paredit (:hint nil)
       ("f" paredit-forward-slurp-sexp "slurp-forward")
       ("F" paredit-forward-barf-sexp "barf-forward")
       ("b" paredit-backward-slurp-sexp "slurp-backward")
       ("B" paredit-backward-barf-sexp "barf-backward")
       ("n" paredit-foward "forward")
       ("p" paredit-backward "backward")
       ("r" paredit-raise-sexp "raise")
       ("s" paredit-splice-sexp "splice")
       ("u" undo-only "undo")
       ("q" nil "quit"))))
#+END_SRC
* magit
#+BEGIN_SRC emacs-lisp
(use-package magit :ensure t
:bind
("C-x g" . magit-status))
#+END_SRC
* git-timemachine
#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :ensure t)
#+END_SRC
* git-gutter
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :ensure t
    :init
    (global-git-gutter-mode +1))
#+END_SRC
* clang-format
#+BEGIN_SRC emacs-lisp
  (use-package clang-format
    :ensure t
    :commands clang-format-buffer clang-format-region
    ;:config
    ;(setq clang-format-executable "TODO")
    :bind(
          ("C-c b" . clang-format-buffer)
          ("C-c r" . clang-format-region)
          )
    )
#+END_SRC
* ess
#+BEGIN_SRC emacs-lisp
  (use-package ess
    :init
    ;my hook mysteriously stopped working so override here
    (setq ess-indent-with-fancy-comments nil)
    (require 'ess-site)
    :config
    (setq inferior-R-program-name "/usr/bin/R")
    (setq inferior-R-args "--no-save")
    (setq ess-eval-visibly-p nil)
    (setq ess-directory "~/")
    (defun ava-ess-settings () ;http://stackoverflow.com/questions/780796/emacs-ess-mode-tabbing-for-comment-region
      (setq ess-indent-with-fancy-comments nil))
    (add-hook 'ess-mode-hook #'ava-ess-settings)
    (define-key ess-r-mode-map "_" #'ess-insert-assign)
    (define-key inferior-ess-r-mode-map "_" #'ess-insert-assign)
    :ensure ess)
#+END_SRC
* elpy
#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :ensure t
    :commands elpy-enable
    :init
    (progn
      (elpy-enable)
      (setq elpy-modules
            '(elpy-module-sane-defaults
              elpy-module-highlight-indentation
              elpy-module-pyvenv
              elpy-module-yasnippet))
      (eval-after-load "elpy"
        '(cl-dolist (key '("C-<return>" "C-<up>" "C-<down>" "C-<left>" "C-<right>"))
           (define-key elpy-mode-map (kbd key) nil)))
      :config
      (setq python-shell-interpreter "jupyter")
      (setq python-shell-interpreter-args "console --simple-prompt")
      (setq elpy-rpc-python-command "python")
      (setq elpy-rpc-timeout 10)
      (setq python-shell-prompt-detect-failure-warning nil)
      (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
      (add-hook 'elpy-mode-hook (lambda () (elpy-shell-toggle-dedicated-shell 1)))
      ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package python-black
    :ensure t
    :after (python)
    :config
    (setq python-black-command "/usr/bin/black"))
#+END_SRC
* erc
#+BEGIN_SRC emacs-lisp
  (use-package erc
    :ensure t
    :config
    (setq erc-hide-list '("PART" "QUIT" "JOIN"))
    (setq erc-server "irc.freenode.net")
    (setq erc-nick "hooxen")
    (add-hook 'erc-text-matched-hook '(lambda (match-type nickuserhost msg)
                                        (shell-command-to-string (format "notify-send erc '%s'" msg))))
    )
#+END_SRC
* elfeed
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :ensure   t
    :commands elfeed
    :config
    (setq-default elfeed-search-filter "@1-week-ago ")
    (setq elfeed-feeds
          '(("https://www.archlinux.org/feeds/news/" arch)
            ("http://www.reddit.com/r/emacs/.rss" emacs reddit)
            ("http://sachachua.com/blog/category/emacs-news/feed" emacs sacha)
            ("http://endlessparentheses.com/atom.xml" emacs)
            ("http://www.masteringemacs.org/feed/" emacs)
            ("http://emacs-fu.blogspot.com/feeds/posts/default" emacs)
            ("http://emacsredux.com/atom.xml" emacs)
            ("http://arxiv.org/rss/q-fin.TR" arxiv trading)
            ("http://feeds.feedburner.com/zerohedge/feed"))
            )
    )
#+END_SRC
* mu4e
The smtp portion will require app specific password and will store it in ~/.authinfo after first use
#+BEGIN_SRC emacs-lisp
  (use-package mu4e
    :load-path "/usr/share/emacs/site-lisp/mu4e"
    :config
    (setq mu4e-maildir (expand-file-name "~/mbsync"))
    (setq mu4e-sent-folder "/sent")
    (setq mu4e-drafts-folder "/drafts")
    (setq mu4e-trash-folder "/trash")

    ;;GMail/IMAP takes care of this
    (setq mu4e-sent-messages-behavior 'delete)
    (setq mu4e-get-mail-command "mbsync -q gmail")
    (setq mu4e-update-interval 3600)
    (setq mu4e-maildir-shortcuts
    '(("/INBOX" . ?i)
      ("/sent" . ?s)))
    (setq mu4e-view-show-images t)
    (setq mu4e-use-fancy-chars t)
    (setq mu4e-view-show-addresses t)
    (setq mu4e-headers-show-threads nil)
    )
  (require 'smtpmail)
  (setq message-send-mail-function 'smtpmail-send-it
        user-mail-address "email_username@gmail.com"
        smtpmail-smtp-user "email_username"
        smtpmail-local-domain "gmail.com"
        smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587)

#+END_SRC
* deadgrep
uses rg for fast grep
#+BEGIN_SRC emacs-lisp
  (use-package deadgrep
    :ensure t
    :bind ("M-s g" . deadgrep))
#+END_SRC
* rmsbolt
#+BEGIN_SRC emacs-lisp
  (use-package rmsbolt
    :ensure t)
#+END_SRC
* elisp
use =paredit= in lisp modes
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :ensure t
    :config
    (add-hook 'emacs-lisp-mode-hook #'paredit-mode)
    (add-hook 'lisp-interaction-mode-hook #'paredit-mode)
    (add-hook 'ielm-mode-hook #'paredit-mode)
    (add-hook 'lisp-mode-hook #'paredit-mode)
    (add-hook 'eval-expression-minibuffer-setup-hook #'paredit-mode))
#+END_SRC
also enable eldoc
#+BEGIN_SRC emacs-lisp
  (use-package eldoc
    :diminish
    :hook ((emacs-lisp-mode) . eldoc-mode))
#+END_SRC
* telega
Telegram support from emacs (needs visual-fill-column)
#+BEGIN_SRC emacs-lisp
  (use-package visual-fill-column
    :ensure t
    )
#+END_SRC
#+BEGIN_SRC emacs-lisp
      (require 'notifications)
      (use-package telega
        :load-path "~/3rdParty/telega/"
        :commands (telega)
        :config
        (setq telega-use-notifications t)
        (add-hook 'telega-chat-mode-hook (lambda ()
                                           (setq company-backends '(telega-company-emoji))
                                           (company-mode 1)))
        :defer t)
#+END_SRC
* leetcode
on MELPA from here [[https://github.com/kaiwk/leetcode][leetcode]]
#+BEGIN_SRC emacs-lisp
  (use-package leetcode
    :ensure t
    :config
    (setq leetcode-prefer-language "cpp")
    (setq leetcode-prefer-sql "mysql"))
#+END_SRC
* projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :init
    (setq projectile-search-path '((expand-file-name "~/development")))
    ;(setq projectile-project-root-files '("WORKSPACE"))
    (setq projectile-project-root-files-bottom-up '(".git" ".projectile"))
    :config
    (projectile-mode t)  
    ;(projectile-register-project-type 'bazel '("WORKSPACE") :compile "bazel build ...")
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    (use-package helm-projectile
      :ensure t
      :init
      (helm-projectile-on)
      (setq projectile-completion-system 'helm)))
#+END_SRC
